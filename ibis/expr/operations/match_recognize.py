from __future__ import annotations

import enum
from public import public
from typing import Optional

import ibis.common.exceptions as exc
import ibis.expr.datashape as ds
import ibis.expr.datatypes as dt
import ibis.expr.rules as rlz
from ibis.common.annotations import attribute
from ibis.common.typing import VarTuple
from ibis.expr.operations.core import Column, Node, Scalar, Value
from ibis.expr.operations.reductions import Filterable, Reduction
from ibis.expr.operations.relations import DatabaseTable, Field, Relation


# Note (mehmet): Added the following ops for two reasons: 1. The
# implementation of `matchrecognize_sql()` in sqlglot makes strict
# assumptions on the inputs of the `MatchRecognize` expression. This is
# why it does not allow massaging the components of `MatchRecognize` to
# get `matchrecognize_sql()` generate the desired SQL.  2. Having
# dedicated ops for the components of complex ops such as
# `MatchRecognize` makes the implementation more readable, e.g., seeing
# all the relevant ops on the graph generated by `.visualize()`.

# TODO (mehmet): In the following classes, I used `Value` as the
# parent class as I could not figure which would be the ideal class
# to extend for each. IMO, `Value` does not fit to most of these
# classes.
@public
class MatchRecognizePartitionBy(Value):
    columns: VarTuple[Column]

    dtype = dt.Unknown
    shape = ds.columnar


@public
class MatchRecognizeOrderBy(Value):
    columns: VarTuple[str | Column]

    dtype = dt.Unknown
    shape = rlz.shape_like("columns")


@public
class Quantifier(Value):
    min_num_rows: int
    max_num_rows: int | None
    reluctant: bool

    dtype = dt.int
    shape = ds.scalar


@public
class MatchRecognizeVariable(Value):
    """Variables to define and measure patterns. """
    name: str
    table: Relation
    definition: Value | None = None
    quantifier: Quantifier | None = None

    shape = ds.scalar

    def to_expr(self):
        from ibis.expr.types.match_recognize import MatchRecognizeVariable

        return MatchRecognizeVariable(self)

    @property
    def dtype(self):
        if self.definition:
            return rlz.dtype_like("definition")
        else:
            return dt.boolean


@public
class MatchRecognizeVariableField(Value):
    field: Field
    variable: MatchRecognizeVariable

    dtype = rlz.dtype_like("field")
    shape = rlz.shape_like("field")

    def to_expr(self):
        super().to_expr()
        from ibis.expr.types.match_recognize import MatchRecognizeVariableField

        return MatchRecognizeVariableField(self)


class LogicalOffset(Filterable, Reduction):
    field: MatchRecognizeVariableField
    offset: int = None

    dtype = rlz.dtype_like("field")


class First(LogicalOffset):
    pass


class Last(LogicalOffset):
    pass


@public
class MatchRecognizeDefine(Value):
    variables: VarTuple[MatchRecognizeVariable]

    dtype = dt.Unknown
    shape = rlz.shape_like("variables")


@public
class MatchRecognizePattern(Value):
    variables: VarTuple[MatchRecognizeVariable]
    # TODO (mehmet): Time interval supported by Flink

    dtype = dt.Unknown
    shape = rlz.shape_like("variables")


@public
class MatchRecognizeMeasure(Value):
    name: str
    definition: Value

    dtype = rlz.dtype_like("definition")
    shape = rlz.shape_like("definition")

    def to_expr(self):
        from ibis.expr.types.match_recognize import MatchRecognizeMeasure

        return MatchRecognizeMeasure(self)


@public
class MatchRecognizeMeasures(Value):
    measures: VarTuple[MatchRecognizeMeasure]

    dtype = dt.Unknown
    shape = rlz.shape_like("measures")


@enum.unique
class AfterMatchStrategy(enum.Enum):
    SKIP_PAST_LAST = enum.auto()
    SKIP_TO_NEXT = enum.auto()
    SKIP_TO_FIRST = enum.auto()
    SKIP_TO_LAST = enum.auto()

    @staticmethod
    def from_str(after_match_strategy: str):
        after_match_strategy = after_match_strategy.upper().replace(" ", "_")
        try:
            return AfterMatchStrategy[after_match_strategy]
        except KeyError:
            raise ValueError(f"Invalid after match strategy: {after_match_strategy}")


# TODO (mehmet): Extending `Value` does not make sense to me.
@public
class MatchRecognizeAfterMatch(Value):
    strategy: AfterMatchStrategy
    variable: MatchRecognizeVariable | None = None

    dtype = dt.Unknown
    shape = ds.scalar

    def to_expr(self):
        from ibis.expr.types.match_recognize import MatchRecognizeAfterMatch

        return MatchRecognizeAfterMatch(self)


@enum.unique
class OutputMode(enum.Enum):
    SINGLE_ROW = enum.auto()
    ALL_ROWS = enum.auto()

    @staticmethod
    def from_str(output_mode: str):
        output_mode = output_mode.upper().replace(" ", "_")
        try:
            return OutputMode[output_mode]
        except ValueError:
            raise ValueError(f"Invalid output mode: {output_mode}")


# TODO (mehmet): Extending `Value` here does not make sense to me.
@public
class MatchRecognizeOutputMode(Value):
    output_mode: OutputMode

    dtype = dt.Unknown
    shape = ds.scalar


@public
class MatchRecognizeTable(DatabaseTable):
    """Table for pattern matching. """
    define: MatchRecognizeDefine
    pattern: MatchRecognizePattern
    measures: MatchRecognizeMeasures
    after_match: MatchRecognizeAfterMatch
    partition_by: MatchRecognizePartitionBy = None
    order_by: MatchRecognizeOrderBy = None
    output_mode: MatchRecognizeOutputMode

    @attribute
    def schema(self):
        from ibis.expr.schema import Schema

        schema_dict = {}

        if self.partition_by:
            for column in self.partition_by.columns:
                schema_dict[column.name] = column.dtype

        for measure in self.measures.measures:
            if measure.name in schema_dict:
                raise IbisInputError(
                    f"Detected a duplicate measurement name: `{measure.name}`."
                    "Measurement names must be unique and different from "
                    "the columns specified in `partition_by`."
                )

            schema_dict[measure.name] = measure.dtype

        return Schema(schema_dict)

    def to_expr(self):
        from ibis.expr.types.match_recognize import MatchRecognizeTable

        return MatchRecognizeTable(self)
