{"version":3,"file":"5276.069ed0f.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/contents.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/emscripten.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/drivefs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/broadcast.js"],"sourcesContent":["import { PageConfig } from '@jupyterlab/coreutils';\nimport mime from 'mime';\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const IContents = new Token('@jupyterlite/contents:IContents');\n/**\n * Commonly-used mimetypes\n */\nexport var MIME;\n(function (MIME) {\n    MIME.JSON = 'application/json';\n    MIME.PLAIN_TEXT = 'text/plain';\n    MIME.OCTET_STREAM = 'octet/stream';\n})(MIME || (MIME = {}));\n/**\n * A namespace for file constructs.\n */\nexport var FILE;\n(function (FILE) {\n    /**\n     * Build-time configured file types.\n     */\n    const TYPES = JSON.parse(PageConfig.getOption('fileTypes') || '{}');\n    /**\n     * Get a mimetype (or fallback).\n     */\n    function getType(ext, defaultType = null) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext && fileType.mimeTypes && fileType.mimeTypes.length) {\n                    return fileType.mimeTypes[0];\n                }\n            }\n        }\n        return mime.getType(ext) || defaultType || MIME.OCTET_STREAM;\n    }\n    FILE.getType = getType;\n    /**\n     * Determine whether the given extension matches a given fileFormat.\n     */\n    function hasFormat(ext, fileFormat) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            if (fileType.fileFormat !== fileFormat) {\n                continue;\n            }\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    FILE.hasFormat = hasFormat;\n})(FILE || (FILE = {}));\n/**\n * The token for the BroadcastChannel broadcaster.\n */\nexport const IBroadcastChannelWrapper = new Token('@jupyterlite/contents:IBroadcastChannelWrapper');\n//# sourceMappingURL=tokens.js.map","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { MIME, FILE } from './tokens';\nimport { PromiseDelegate } from '@lumino/coreutils';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\n/**\n * A class to handle requests to /api/contents\n */\nexport class Contents {\n    /**\n     * Construct a new localForage-powered contents provider\n     */\n    constructor(options) {\n        /**\n         * A reducer for turning arbitrary binary into a string\n         */\n        this.reduceBytesToString = (data, byte) => {\n            return data + String.fromCharCode(byte);\n        };\n        this._serverContents = new Map();\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageDrivers = null;\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n    }\n    /**\n     * Finish any initialization after server has started and all extensions are applied.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * Initialize all storage instances\n     */\n    async initStorage() {\n        this._storage = this.createDefaultStorage();\n        this._counters = this.createDefaultCounters();\n        this._checkpoints = this.createDefaultCheckpoints();\n    }\n    /**\n     * A promise that resolves once all storage is fully initialized.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * A lazy reference to the underlying storage.\n     */\n    get storage() {\n        return this.ready.then(() => this._storage);\n    }\n    /**\n     * A lazy reference to the underlying counters.\n     */\n    get counters() {\n        return this.ready.then(() => this._counters);\n    }\n    /**\n     * A lazy reference to the underlying checkpoints.\n     */\n    get checkpoints() {\n        return this.ready.then(() => this._checkpoints);\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createDefaultStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Notebooks and Files',\n            storeName: 'files',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Initialize the default storage for counting file suffixes.\n     */\n    createDefaultCounters() {\n        return this._localforage.createInstance({\n            description: 'Store the current file suffix counters',\n            storeName: 'counters',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create the default checkpoint storage.\n     */\n    createDefaultCheckpoints() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Checkpoints',\n            storeName: 'checkpoints',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the file is created.\n     */\n    async newUntitled(options) {\n        var _a, _b, _c;\n        const path = (_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : '';\n        const type = (_b = options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : 'notebook';\n        const created = new Date().toISOString();\n        let dirname = PathExt.dirname(path);\n        const basename = PathExt.basename(path);\n        const extname = PathExt.extname(path);\n        const item = await this.get(dirname);\n        // handle the case of \"Save As\", where the path points to the new file\n        // to create, e.g. subfolder/example-copy.ipynb\n        let name = '';\n        if (path && !extname && item) {\n            // directory\n            dirname = `${path}/`;\n            name = '';\n        }\n        else if (dirname && basename) {\n            // file in a subfolder\n            dirname = `${dirname}/`;\n            name = basename;\n        }\n        else {\n            // file at the top level\n            dirname = '';\n            name = path;\n        }\n        let file;\n        switch (type) {\n            case 'directory': {\n                const counter = await this._incrementCounter('directory');\n                name = `Untitled Folder${counter || ''}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: '',\n                    content: null,\n                    size: 0,\n                    writable: true,\n                    type: 'directory',\n                };\n                break;\n            }\n            case 'notebook': {\n                const counter = await this._incrementCounter('notebook');\n                name = name || `Untitled${counter || ''}.ipynb`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: MIME.JSON,\n                    content: Private.EMPTY_NB,\n                    size: JSON.stringify(Private.EMPTY_NB).length,\n                    writable: true,\n                    type: 'notebook',\n                };\n                break;\n            }\n            default: {\n                const ext = (_c = options === null || options === void 0 ? void 0 : options.ext) !== null && _c !== void 0 ? _c : '.txt';\n                const counter = await this._incrementCounter('file');\n                const mimetype = FILE.getType(ext) || MIME.OCTET_STREAM;\n                let format;\n                if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    format = 'text';\n                }\n                else if (ext.indexOf('json') !== -1 || ext.indexOf('ipynb') !== -1) {\n                    format = 'json';\n                }\n                else {\n                    format = 'base64';\n                }\n                name = name || `untitled${counter || ''}${ext}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format,\n                    mimetype,\n                    content: '',\n                    size: 0,\n                    writable: true,\n                    type: 'file',\n                };\n                break;\n            }\n        }\n        const key = file.path;\n        await (await this.storage).setItem(key, file);\n        return file;\n    }\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new contents model when the\n     *  file is copied.\n     *\n     * #### Notes\n     * The server will select the name of the copied file.\n     */\n    async copy(path, toDir) {\n        let name = PathExt.basename(path);\n        toDir = toDir === '' ? '' : `${toDir.slice(1)}/`;\n        // TODO: better handle naming collisions with existing files\n        while (await this.get(`${toDir}${name}`, { content: true })) {\n            const ext = PathExt.extname(name);\n            const base = name.replace(ext, '');\n            name = `${base} (copy)${ext}`;\n        }\n        const toPath = `${toDir}${name}`;\n        let item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        item = {\n            ...item,\n            name,\n            path: toPath,\n        };\n        await (await this.storage).setItem(toPath, item);\n        return item;\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(path, options) {\n        // remove leading slash\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        if (path === '') {\n            return await this._getFolder(path);\n        }\n        const storage = await this.storage;\n        const item = await storage.getItem(path);\n        const serverItem = await this._getServerContents(path, options);\n        const model = (item || serverItem);\n        if (!model) {\n            return null;\n        }\n        if (!(options === null || options === void 0 ? void 0 : options.content)) {\n            return {\n                size: 0,\n                ...model,\n                content: null,\n            };\n        }\n        // for directories, find all files with the path as the prefix\n        if (model.type === 'directory') {\n            const contentMap = new Map();\n            await storage.iterate((file, key) => {\n                // use an additional slash to not include the directory itself\n                if (key === `${path}/${file.name}`) {\n                    contentMap.set(file.name, file);\n                }\n            });\n            const serverContents = serverItem\n                ? serverItem.content\n                : Array.from((await this._getServerDirectory(path)).values());\n            for (const file of serverContents) {\n                if (!contentMap.has(file.name)) {\n                    contentMap.set(file.name, file);\n                }\n            }\n            const content = [...contentMap.values()];\n            return {\n                name: PathExt.basename(path),\n                path,\n                last_modified: model.last_modified,\n                created: model.created,\n                format: 'json',\n                mimetype: MIME.JSON,\n                content,\n                size: 0,\n                writable: true,\n                type: 'directory',\n            };\n        }\n        return model;\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the file is renamed.\n     */\n    async rename(oldLocalPath, newLocalPath) {\n        const path = decodeURIComponent(oldLocalPath);\n        const file = await this.get(path, { content: true });\n        if (!file) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const modified = new Date().toISOString();\n        const name = PathExt.basename(newLocalPath);\n        const newFile = {\n            ...file,\n            name,\n            path: newLocalPath,\n            last_modified: modified,\n        };\n        const storage = await this.storage;\n        await storage.setItem(newLocalPath, newFile);\n        // remove the old file\n        await storage.removeItem(path);\n        // remove the corresponding checkpoint\n        await (await this.checkpoints).removeItem(path);\n        // if a directory, recurse through all children\n        if (file.type === 'directory') {\n            let child;\n            for (child of file.content) {\n                await this.rename(URLExt.join(oldLocalPath, child.name), URLExt.join(newLocalPath, child.name));\n            }\n        }\n        return newFile;\n    }\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the file is saved.\n     */\n    async save(path, options = {}) {\n        var _a;\n        path = decodeURIComponent(path);\n        // process the file if coming from an upload\n        const ext = PathExt.extname((_a = options.name) !== null && _a !== void 0 ? _a : '');\n        const chunk = options.chunk;\n        // retrieve the content if it is a later chunk or the last one\n        // the new content will then be appended to the existing one\n        const chunked = chunk ? chunk > 1 || chunk === -1 : false;\n        let item = await this.get(path, { content: chunked });\n        if (!item) {\n            item = await this.newUntitled({ path, ext, type: 'file' });\n        }\n        if (!item) {\n            return null;\n        }\n        // keep a reference to the original content\n        const originalContent = item.content;\n        const modified = new Date().toISOString();\n        // override with the new values\n        item = {\n            ...item,\n            ...options,\n            last_modified: modified,\n        };\n        if (options.content && options.format === 'base64') {\n            const lastChunk = chunk ? chunk === -1 : true;\n            if (ext === '.ipynb') {\n                const content = this._handleChunk(options.content, originalContent, chunked);\n                item = {\n                    ...item,\n                    content: lastChunk ? JSON.parse(content) : content,\n                    format: 'json',\n                    type: 'notebook',\n                    size: content.length,\n                };\n            }\n            else if (FILE.hasFormat(ext, 'json')) {\n                const content = this._handleChunk(options.content, originalContent, chunked);\n                item = {\n                    ...item,\n                    content: lastChunk ? JSON.parse(content) : content,\n                    format: 'json',\n                    type: 'file',\n                    size: content.length,\n                };\n            }\n            else if (FILE.hasFormat(ext, 'text')) {\n                const content = this._handleChunk(options.content, originalContent, chunked);\n                item = {\n                    ...item,\n                    content,\n                    format: 'text',\n                    type: 'file',\n                    size: content.length,\n                };\n            }\n            else {\n                const content = options.content;\n                item = {\n                    ...item,\n                    content,\n                    size: atob(content).length,\n                };\n            }\n        }\n        await (await this.storage).setItem(path, item);\n        return item;\n    }\n    /**\n     * Delete a file from browser storage.\n     *\n     * Has no effect on server-backed files, which will re-appear with their\n     * original timestamp.\n     *\n     * @param path - The path to the file.\n     */\n    async delete(path) {\n        path = decodeURIComponent(path);\n        const slashed = `${path}/`;\n        const toDelete = (await (await this.storage).keys()).filter((key) => key === path || key.startsWith(slashed));\n        await Promise.all(toDelete.map(this.forgetPath, this));\n    }\n    /**\n     * Remove the localForage and checkpoints for a path.\n     *\n     * @param path - The path to the file\n     */\n    async forgetPath(path) {\n        await Promise.all([\n            (await this.storage).removeItem(path),\n            (await this.checkpoints).removeItem(path),\n        ]);\n    }\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    async createCheckpoint(path) {\n        var _a;\n        const checkpoints = await this.checkpoints;\n        path = decodeURIComponent(path);\n        const item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const copies = ((_a = (await checkpoints.getItem(path))) !== null && _a !== void 0 ? _a : []).filter(Boolean);\n        copies.push(item);\n        // keep only a certain amount of checkpoints per file\n        if (copies.length > N_CHECKPOINTS) {\n            copies.splice(0, copies.length - N_CHECKPOINTS);\n        }\n        await checkpoints.setItem(path, copies);\n        const id = `${copies.length - 1}`;\n        return { id, last_modified: item.last_modified };\n    }\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    async listCheckpoints(path) {\n        const copies = (await (await this.checkpoints).getItem(path)) || [];\n        return copies.filter(Boolean).map(this.normalizeCheckpoint, this);\n    }\n    normalizeCheckpoint(model, id) {\n        return { id: id.toString(), last_modified: model.last_modified };\n    }\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    async restoreCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        const item = copies[id];\n        await (await this.storage).setItem(path, item);\n    }\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    async deleteCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        copies.splice(id, 1);\n        await (await this.checkpoints).setItem(path, copies);\n    }\n    /**\n     * Handle a chunk of a file.\n     * Decode and unescape a base64-encoded string.\n     * @param content the content to process\n     *\n     * @returns the decoded string, appended to the original content if chunked\n     * /\n     */\n    _handleChunk(newContent, originalContent, chunked) {\n        const escaped = decodeURIComponent(escape(atob(newContent)));\n        const content = chunked ? originalContent + escaped : escaped;\n        return content;\n    }\n    /**\n     * retrieve the contents for this path from the union of local storage and\n     * `api/contents/{path}/all.json`.\n     *\n     * @param path - The contents path to retrieve\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getFolder(path) {\n        const content = new Map();\n        const storage = await this.storage;\n        await storage.iterate((file, key) => {\n            if (key.includes('/')) {\n                return;\n            }\n            content.set(file.path, file);\n        });\n        // layer in contents that don't have local overwrites\n        for (const file of (await this._getServerDirectory(path)).values()) {\n            if (!content.has(file.path)) {\n                content.set(file.path, file);\n            }\n        }\n        if (path && content.size === 0) {\n            return null;\n        }\n        return {\n            name: '',\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'json',\n            mimetype: MIME.JSON,\n            content: Array.from(content.values()),\n            size: 0,\n            writable: true,\n            type: 'directory',\n        };\n    }\n    /**\n     * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n     * deriving the model (including content) off the file in `/files/`. Otherwise\n     * return `null`.\n     */\n    async _getServerContents(path, options) {\n        const name = PathExt.basename(path);\n        const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n        let model = parentContents.get(name);\n        if (!model) {\n            return null;\n        }\n        model = model || {\n            name,\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'text',\n            mimetype: MIME.PLAIN_TEXT,\n            type: 'file',\n            writable: true,\n            size: 0,\n            content: '',\n        };\n        if (options === null || options === void 0 ? void 0 : options.content) {\n            if (model.type === 'directory') {\n                const serverContents = await this._getServerDirectory(path);\n                model = { ...model, content: Array.from(serverContents.values()) };\n            }\n            else {\n                const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n                const response = await fetch(fileUrl);\n                if (!response.ok) {\n                    return null;\n                }\n                const mimetype = model.mimetype || response.headers.get('Content-Type');\n                const ext = PathExt.extname(name);\n                if (model.type === 'notebook' ||\n                    FILE.hasFormat(ext, 'json') ||\n                    (mimetype === null || mimetype === void 0 ? void 0 : mimetype.indexOf('json')) !== -1 ||\n                    path.match(/\\.(ipynb|[^/]*json[^/]*)$/)) {\n                    const contentText = await response.text();\n                    model = {\n                        ...model,\n                        content: JSON.parse(contentText),\n                        format: 'json',\n                        mimetype: model.mimetype || MIME.JSON,\n                        size: contentText.length,\n                    };\n                }\n                else if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    const contentText = await response.text();\n                    model = {\n                        ...model,\n                        content: contentText,\n                        format: 'text',\n                        mimetype: mimetype || MIME.PLAIN_TEXT,\n                        size: contentText.length,\n                    };\n                }\n                else {\n                    const contentBytes = await response.arrayBuffer();\n                    const contentBuffer = new Uint8Array(contentBytes);\n                    model = {\n                        ...model,\n                        content: btoa(contentBuffer.reduce(this.reduceBytesToString, '')),\n                        format: 'base64',\n                        mimetype: mimetype || MIME.OCTET_STREAM,\n                        size: contentBuffer.length,\n                    };\n                }\n            }\n        }\n        return model;\n    }\n    /**\n     * retrieve the contents for this path from `__index__.json` in the appropriate\n     * folder.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getServerDirectory(path) {\n        const content = this._serverContents.get(path) || new Map();\n        if (!this._serverContents.has(path)) {\n            const apiURL = URLExt.join(PageConfig.getBaseUrl(), 'api/contents', path, 'all.json');\n            try {\n                const response = await fetch(apiURL);\n                const json = JSON.parse(await response.text());\n                for (const file of json['content']) {\n                    content.set(file.name, file);\n                }\n            }\n            catch (err) {\n                console.warn(`don't worry, about ${err}... nothing's broken. If there had been a\n          file at ${apiURL}, you might see some more files.`);\n            }\n            this._serverContents.set(path, content);\n        }\n        return content;\n    }\n    /**\n     * Increment the counter for a given file type.\n     * Used to avoid collisions when creating new untitled files.\n     *\n     * @param type The file type to increment the counter for.\n     */\n    async _incrementCounter(type) {\n        var _a;\n        const counters = await this.counters;\n        const current = (_a = (await counters.getItem(type))) !== null && _a !== void 0 ? _a : -1;\n        const counter = current + 1;\n        await counters.setItem(type, counter);\n        return counter;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The content for an empty notebook.\n     */\n    Private.EMPTY_NB = {\n        metadata: {\n            orig_nbformat: 4,\n        },\n        nbformat_minor: 4,\n        nbformat: 4,\n        cells: [],\n    };\n})(Private || (Private = {}));\n//# sourceMappingURL=contents.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/// <reference path=\"../../../node_modules/@types/emscripten/index.d.ts\" />\nexport const DIR_MODE = 16895; // 040777\nexport const FILE_MODE = 33206; // 100666\nexport const SEEK_CUR = 1;\nexport const SEEK_END = 2;\n//# sourceMappingURL=emscripten.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n// Types and implementation inspired from https://github.com/jvilk/BrowserFS\n// LICENSE: https://github.com/jvilk/BrowserFS/blob/8977a704ea469d05daf857e4818bef1f4f498326/LICENSE\n// And from https://github.com/gzuidhof/starboard-notebook\n// LICENSE: https://github.com/gzuidhof/starboard-notebook/blob/cd8d3fc30af4bd29cdd8f6b8c207df8138f5d5dd/LICENSE\nimport { DIR_MODE, SEEK_CUR, SEEK_END, } from './emscripten';\nexport const DRIVE_SEPARATOR = ':';\nexport const DRIVE_API_PATH = '/api/drive.v1';\nexport const BLOCK_SIZE = 4096;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n// Mapping flag -> do we need to overwrite the file upon closing it\nconst flagNeedsWrite = {\n    0 /*O_RDONLY*/: false,\n    1 /*O_WRONLY*/: true,\n    2 /*O_RDWR*/: true,\n    64 /*O_CREAT*/: true,\n    65 /*O_WRONLY|O_CREAT*/: true,\n    66 /*O_RDWR|O_CREAT*/: true,\n    129 /*O_WRONLY|O_EXCL*/: true,\n    193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,\n    514 /*O_RDWR|O_TRUNC*/: true,\n    577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,\n    578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,\n    705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    1024 /*O_APPEND*/: true,\n    1025 /*O_WRONLY|O_APPEND*/: true,\n    1026 /*O_RDWR|O_APPEND*/: true,\n    1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,\n    1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,\n    1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,\n    1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,\n    1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,\n    1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,\n    4096 /*O_RDONLY|O_DSYNC*/: true,\n    4098 /*O_RDWR|O_DSYNC*/: true,\n};\nexport class DriveFSEmscriptenStreamOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    open(stream) {\n        const path = this.fs.realPath(stream.node);\n        if (this.fs.FS.isFile(stream.node.mode)) {\n            stream.file = this.fs.API.get(path);\n        }\n    }\n    close(stream) {\n        if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {\n            return;\n        }\n        const path = this.fs.realPath(stream.node);\n        const flags = stream.flags;\n        let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n        parsedFlags &= 0x1fff;\n        let needsWrite = true;\n        if (parsedFlags in flagNeedsWrite) {\n            needsWrite = flagNeedsWrite[parsedFlags];\n        }\n        if (needsWrite) {\n            this.fs.API.put(path, stream.file);\n        }\n        stream.file = undefined;\n    }\n    read(stream, buffer, offset, length, position) {\n        if (length <= 0 ||\n            stream.file === undefined ||\n            position >= (stream.file.data.length || 0)) {\n            return 0;\n        }\n        const size = Math.min(stream.file.data.length - position, length);\n        buffer.set(stream.file.data.subarray(position, position + size), offset);\n        return size;\n    }\n    write(stream, buffer, offset, length, position) {\n        var _a;\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        stream.node.timestamp = Date.now();\n        if (position + length > (((_a = stream.file) === null || _a === void 0 ? void 0 : _a.data.length) || 0)) {\n            const oldData = stream.file.data ? stream.file.data : new Uint8Array();\n            stream.file.data = new Uint8Array(position + length);\n            stream.file.data.set(oldData);\n        }\n        stream.file.data.set(buffer.subarray(offset, offset + length), position);\n        return length;\n    }\n    llseek(stream, offset, whence) {\n        let position = offset;\n        if (whence === SEEK_CUR) {\n            position += stream.position;\n        }\n        else if (whence === SEEK_END) {\n            if (this.fs.FS.isFile(stream.node.mode)) {\n                if (stream.file !== undefined) {\n                    position += stream.file.data.length;\n                }\n                else {\n                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EPERM);\n                }\n            }\n        }\n        if (position < 0) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EINVAL);\n        }\n        return position;\n    }\n}\nexport class DriveFSEmscriptenNodeOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    getattr(node) {\n        return {\n            ...this.fs.API.getattr(this.fs.realPath(node)),\n            mode: node.mode,\n            ino: node.id,\n        };\n    }\n    setattr(node, attr) {\n        for (const [key, value] of Object.entries(attr)) {\n            switch (key) {\n                case 'mode':\n                    node.mode = value;\n                    break;\n                case 'timestamp':\n                    node.timestamp = value;\n                    break;\n                default:\n                    console.warn('setattr', key, 'of', value, 'on', node, 'not yet implemented');\n                    break;\n            }\n        }\n    }\n    lookup(parent, name) {\n        const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n        const result = this.fs.API.lookup(path);\n        if (!result.ok) {\n            throw this.fs.FS.genericErrors[this.fs.ERRNO_CODES['ENOENT']];\n        }\n        return this.fs.createNode(parent, name, result.mode, 0);\n    }\n    mknod(parent, name, mode, dev) {\n        const path = this.fs.PATH.join2(this.fs.realPath(parent), name);\n        this.fs.API.mknod(path, mode);\n        return this.fs.createNode(parent, name, mode, dev);\n    }\n    rename(oldNode, newDir, newName) {\n        this.fs.API.rename(oldNode.parent\n            ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)\n            : oldNode.name, this.fs.PATH.join2(this.fs.realPath(newDir), newName));\n        // Updating the in-memory node\n        oldNode.name = newName;\n        oldNode.parent = newDir;\n    }\n    unlink(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n    }\n    rmdir(parent, name) {\n        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(parent), name));\n    }\n    readdir(node) {\n        return this.fs.API.readdir(this.fs.realPath(node));\n    }\n    symlink(parent, newName, oldPath) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n    readlink(node) {\n        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n    }\n}\n/**\n * Wrap ServiceWorker requests for an Emscripten-compatible synchronous API.\n */\nexport class ContentsAPI {\n    constructor(baseUrl, driveName, mountpoint, FS, ERRNO_CODES) {\n        this._baseUrl = baseUrl;\n        this._driveName = driveName;\n        this._mountpoint = mountpoint;\n        this.FS = FS;\n        this.ERRNO_CODES = ERRNO_CODES;\n    }\n    request(data) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', encodeURI(this.endpoint), false);\n        try {\n            xhr.send(JSON.stringify(data));\n        }\n        catch (e) {\n            console.error(e);\n        }\n        if (xhr.status >= 400) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        return JSON.parse(xhr.responseText);\n    }\n    lookup(path) {\n        return this.request({ method: 'lookup', path: this.normalizePath(path) });\n    }\n    getmode(path) {\n        return Number.parseInt(this.request({ method: 'getmode', path: this.normalizePath(path) }));\n    }\n    mknod(path, mode) {\n        return this.request({\n            method: 'mknod',\n            path: this.normalizePath(path),\n            data: { mode },\n        });\n    }\n    rename(oldPath, newPath) {\n        return this.request({\n            method: 'rename',\n            path: this.normalizePath(oldPath),\n            data: { newPath: this.normalizePath(newPath) },\n        });\n    }\n    readdir(path) {\n        const dirlist = this.request({\n            method: 'readdir',\n            path: this.normalizePath(path),\n        });\n        dirlist.push('.');\n        dirlist.push('..');\n        return dirlist;\n    }\n    rmdir(path) {\n        return this.request({ method: 'rmdir', path: this.normalizePath(path) });\n    }\n    get(path) {\n        const response = this.request({ method: 'get', path: this.normalizePath(path) });\n        const serializedContent = response.content;\n        const format = response.format;\n        switch (format) {\n            case 'json':\n            case 'text':\n                return {\n                    data: encoder.encode(serializedContent),\n                    format,\n                };\n            case 'base64': {\n                const binString = atob(serializedContent);\n                const len = binString.length;\n                const data = new Uint8Array(len);\n                for (let i = 0; i < len; i++) {\n                    data[i] = binString.charCodeAt(i);\n                }\n                return {\n                    data,\n                    format,\n                };\n            }\n            default:\n                throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n    }\n    put(path, value) {\n        switch (value.format) {\n            case 'json':\n            case 'text':\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: decoder.decode(value.data),\n                    },\n                });\n            case 'base64': {\n                let binary = '';\n                for (let i = 0; i < value.data.byteLength; i++) {\n                    binary += String.fromCharCode(value.data[i]);\n                }\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: btoa(binary),\n                    },\n                });\n            }\n        }\n    }\n    getattr(path) {\n        const stats = this.request({\n            method: 'getattr',\n            path: this.normalizePath(path),\n        });\n        // Turn datetimes into proper objects\n        stats.atime = new Date(stats.atime);\n        stats.mtime = new Date(stats.mtime);\n        stats.ctime = new Date(stats.ctime);\n        // ensure a non-undefined size (0 isn't great, though)\n        stats.size = stats.size || 0;\n        return stats;\n    }\n    /**\n     * Normalize a Path by making it compliant for the content manager\n     *\n     * @param path: the path relatively to the Emscripten drive\n     */\n    normalizePath(path) {\n        // Remove mountpoint prefix\n        if (path.startsWith(this._mountpoint)) {\n            path = path.slice(this._mountpoint.length);\n        }\n        // Add JupyterLab drive name\n        if (this._driveName) {\n            path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;\n        }\n        return path;\n    }\n    /**\n     * Get the api/drive endpoint\n     */\n    get endpoint() {\n        return `${this._baseUrl}api/drive`;\n    }\n}\nexport class DriveFS {\n    constructor(options) {\n        this.FS = options.FS;\n        this.PATH = options.PATH;\n        this.ERRNO_CODES = options.ERRNO_CODES;\n        this.API = new ContentsAPI(options.baseUrl, options.driveName, options.mountpoint, this.FS, this.ERRNO_CODES);\n        this.driveName = options.driveName;\n        this.node_ops = new DriveFSEmscriptenNodeOps(this);\n        this.stream_ops = new DriveFSEmscriptenStreamOps(this);\n    }\n    mount(mount) {\n        return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);\n    }\n    createNode(parent, name, mode, dev) {\n        const FS = this.FS;\n        if (!FS.isDir(mode) && !FS.isFile(mode)) {\n            throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        const node = FS.createNode(parent, name, mode, dev);\n        node.node_ops = this.node_ops;\n        node.stream_ops = this.stream_ops;\n        return node;\n    }\n    getMode(path) {\n        return this.API.getmode(path);\n    }\n    realPath(node) {\n        const parts = [];\n        let currentNode = node;\n        parts.push(currentNode.name);\n        while (currentNode.parent !== currentNode) {\n            currentNode = currentNode.parent;\n            parts.push(currentNode.name);\n        }\n        parts.reverse();\n        return this.PATH.join.apply(null, parts);\n    }\n}\n//# sourceMappingURL=drivefs.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { DIR_MODE, FILE_MODE } from './emscripten';\nimport { BLOCK_SIZE, DRIVE_API_PATH } from './drivefs';\n/** A broadcaster for the ServiceWorker */\nexport class BroadcastChannelWrapper {\n    constructor(options) {\n        this.isDisposed = false;\n        /** Handle a message received on the BroadcastChannel */\n        this._onMessage = async (event) => {\n            if (!this._channel) {\n                return;\n            }\n            const { _contents } = this;\n            const request = event.data;\n            const path = request === null || request === void 0 ? void 0 : request.path;\n            const receiver = request === null || request === void 0 ? void 0 : request.receiver;\n            if (receiver !== 'broadcast.ts') {\n                // Message is not meant for us\n                return;\n            }\n            // many successful responses default to null\n            let response = null;\n            // most requests will use a model\n            let model;\n            switch (request === null || request === void 0 ? void 0 : request.method) {\n                case 'readdir':\n                    model = await _contents.get(path, { content: true });\n                    response = [];\n                    if (model.type === 'directory' && model.content) {\n                        response = model.content.map((subcontent) => subcontent.name);\n                    }\n                    break;\n                case 'rmdir':\n                    await _contents.delete(path);\n                    break;\n                case 'rename':\n                    await _contents.rename(path, request.data.newPath);\n                    break;\n                case 'getmode':\n                    model = await _contents.get(path);\n                    if (model.type === 'directory') {\n                        response = DIR_MODE;\n                    }\n                    else {\n                        response = FILE_MODE;\n                    }\n                    break;\n                case 'lookup':\n                    try {\n                        model = await _contents.get(path);\n                        response = {\n                            ok: true,\n                            mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n                        };\n                    }\n                    catch (e) {\n                        response = { ok: false };\n                    }\n                    break;\n                case 'mknod':\n                    model = await _contents.newUntitled({\n                        path: PathExt.dirname(path),\n                        type: Number.parseInt(request.data.mode) === DIR_MODE ? 'directory' : 'file',\n                        ext: PathExt.extname(path),\n                    });\n                    await _contents.rename(model.path, path);\n                    break;\n                case 'getattr': {\n                    model = await _contents.get(path);\n                    // create a default date for drives that send incomplete information\n                    // for nested foldes and files\n                    const defaultDate = new Date(0).toISOString();\n                    response = {\n                        dev: 1,\n                        nlink: 1,\n                        uid: 0,\n                        gid: 0,\n                        rdev: 0,\n                        size: model.size || 0,\n                        blksize: BLOCK_SIZE,\n                        blocks: Math.ceil(model.size || 0 / BLOCK_SIZE),\n                        atime: model.last_modified || defaultDate,\n                        mtime: model.last_modified || defaultDate,\n                        ctime: model.created || defaultDate,\n                        timestamp: 0,\n                    };\n                    break;\n                }\n                case 'get':\n                    model = await _contents.get(path, { content: true });\n                    if (model.type === 'directory') {\n                        break;\n                    }\n                    response = {\n                        content: model.format === 'json' ? JSON.stringify(model.content) : model.content,\n                        format: model.format,\n                    };\n                    break;\n                case 'put':\n                    await _contents.save(path, {\n                        content: request.data.format === 'json'\n                            ? JSON.parse(request.data.data)\n                            : request.data.data,\n                        type: 'file',\n                        format: request.data.format,\n                    });\n                    break;\n                default:\n                    response = null;\n                    break;\n            }\n            this._channel.postMessage(response);\n        };\n        this._channel = null;\n        this._enabled = false;\n        this._contents = options.contents;\n    }\n    get enabled() {\n        return this._enabled;\n    }\n    enable() {\n        if (this._channel) {\n            console.warn('BroadcastChannel already created and enabled');\n            return;\n        }\n        this._channel = new BroadcastChannel(DRIVE_API_PATH);\n        this._channel.addEventListener('message', this._onMessage);\n        this._enabled = true;\n    }\n    disable() {\n        if (this._channel) {\n            this._channel.removeEventListener('message', this._onMessage);\n            this._channel = null;\n        }\n        this._enabled = false;\n    }\n    /** Clean up the broadcaster. */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.disable();\n        this.isDisposed = true;\n    }\n}\n//# sourceMappingURL=broadcast.js.map"],"names":["IContents","Token","MIME","FILE","JSON","PLAIN_TEXT","OCTET_STREAM","TYPES","parse","PageConfig","getOption","getType","ext","defaultType","toLowerCase","fileType","Object","values","fileExt","extensions","mimeTypes","length","hasFormat","fileFormat","IBroadcastChannelWrapper","DEFAULT_STORAGE_NAME","Contents","constructor","options","this","reduceBytesToString","data","byte","String","fromCharCode","_serverContents","Map","_storageName","_storageDrivers","_localforage","localforage","storageName","storageDrivers","_ready","PromiseDelegate","initialize","initStorage","resolve","_storage","createDefaultStorage","_counters","createDefaultCounters","_checkpoints","createDefaultCheckpoints","ready","promise","storage","then","counters","checkpoints","defaultStorageOptions","driver","version","name","createInstance","description","storeName","newUntitled","_a","_b","_c","path","type","created","Date","toISOString","dirname","PathExt","basename","extname","item","get","file","_incrementCounter","last_modified","format","mimetype","content","size","writable","counter","Private","EMPTY_NB","stringify","indexOf","key","setItem","copy","toDir","slice","base","replace","toPath","Error","decodeURIComponent","_getFolder","getItem","serverItem","_getServerContents","model","contentMap","iterate","set","serverContents","Array","from","_getServerDirectory","has","rename","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","URLExt","join","save","chunk","chunked","originalContent","lastChunk","_handleChunk","atob","slashed","toDelete","keys","filter","startsWith","Promise","all","map","forgetPath","createCheckpoint","copies","Boolean","push","splice","id","listCheckpoints","normalizeCheckpoint","toString","restoreCheckpoint","checkpointID","parseInt","deleteCheckpoint","newContent","escaped","escape","includes","fileUrl","getBaseUrl","response","fetch","ok","headers","match","contentText","text","contentBytes","arrayBuffer","contentBuffer","Uint8Array","btoa","reduce","apiURL","json","err","console","warn","metadata","orig_nbformat","nbformat_minor","nbformat","cells","DIR_MODE","FILE_MODE","SEEK_CUR","SEEK_END","DRIVE_SEPARATOR","DRIVE_API_PATH","BLOCK_SIZE","encoder","TextEncoder","decoder","TextDecoder","flagNeedsWrite","DriveFSEmscriptenStreamOps","fs","open","stream","realPath","node","FS","isFile","mode","API","close","flags","parsedFlags","needsWrite","put","undefined","read","buffer","offset","position","Math","min","subarray","write","timestamp","now","oldData","llseek","whence","ErrnoError","ERRNO_CODES","EPERM","EINVAL","DriveFSEmscriptenNodeOps","getattr","ino","setattr","attr","value","entries","lookup","parent","PATH","join2","result","genericErrors","createNode","mknod","dev","oldNode","newDir","newName","unlink","rmdir","readdir","symlink","oldPath","readlink","ContentsAPI","baseUrl","driveName","mountpoint","_baseUrl","_driveName","_mountpoint","request","xhr","XMLHttpRequest","encodeURI","endpoint","send","e","error","status","responseText","method","normalizePath","getmode","Number","newPath","dirlist","serializedContent","encode","binString","len","i","charCodeAt","decode","binary","byteLength","stats","atime","mtime","ctime","DriveFS","node_ops","stream_ops","mount","isDir","getMode","parts","currentNode","reverse","apply","BroadcastChannelWrapper","isDisposed","_onMessage","async","event","_channel","_contents","receiver","subcontent","delete","defaultDate","nlink","uid","gid","rdev","blksize","blocks","ceil","postMessage","_enabled","contents","enabled","enable","BroadcastChannel","addEventListener","disable","removeEventListener","dispose"],"sourceRoot":""}