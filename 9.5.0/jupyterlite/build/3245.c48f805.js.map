{"version":3,"file":"3245.c48f805.js","mappings":"4OAOO,MAAMA,EAAuB,4BAIvBC,EAAY,IAAI,EAAAC,MAAM,mCCJ7BC,EAAeC,OAAOC,OAAO,CAAEC,SAAU,KAIxC,MAAMC,EAIT,SAAMC,GACF,MAAO,CACHC,QAAS,UACKC,KAAKC,gBACf,CAACD,KAAKE,eAAgBF,KAAKG,mBAGvC,CAIA,WAAID,GACA,OAAO,EAAAE,WAAWC,UAAU,YAAc,aAC9C,CAIA,kBAAIC,GACA,OAAO,EAAAC,OAAOC,KAAK,EAAAJ,WAAWK,aAAc,QAASnB,EACzD,CAIA,oBAAIoB,GACA,OAAO,EAAAN,WAAWC,UAAU,uBAChC,CAIA,qBAAMF,GACF,IAAIQ,EAASlB,EACb,IAEIkB,SADuBC,MAAMZ,KAAKM,iBAChBO,MACtB,CACA,MAAOC,GACHC,QAAQC,KAAK,iCAAkChB,KAAKE,QACxD,CACA,OAAOS,CACX,CAIA,mBAAMV,GACF,MAAMF,EAAU,CAAC,EACjB,IAAIkB,EACJ,IACIA,EAAYC,KAAKC,MAAM,EAAAf,WAAWC,UAAU,wBAChD,CACA,MACI,OAAON,CACX,CACA,MAAMqB,EAAW,GACjB,IAAK,MAAMC,KAAOJ,EACdG,EAASE,KAAKtB,KAAKuB,iBAAiBF,EAAKtB,IAE7C,UACUyB,QAAQC,IAAIL,EACtB,CACA,MAAON,GACHC,QAAQC,KAAK,2BAA4BF,EAC7C,CACA,OAAOf,CACX,CAIA,sBAAMwB,CAAiBF,EAAKtB,GACxB,IACI,MAAM2B,EAAM,EAAAnB,OAAOC,KAAKR,KAAKU,iBAAkBW,EAAIM,KAAM,SAAUrC,GAC7DsC,QAAiBhB,MAAMc,GAC7B3B,EAAQsB,EAAIM,YAAcC,EAASf,MACvC,CACA,MACIE,QAAQC,KAAK,iCAAkCK,GAC/CtB,EAAQsB,EAAIM,MAAQlC,CACxB,CACJ,E","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/licenses/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/licenses/lib/licenses.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The well-known name of the file. Can actually be configured by alternate\n * implementations, but the default is probably good enough for \"best-effort.\"\n */\nexport const THIRD_PARTY_LICENSES = 'third-party-licenses.json';\n/**\n * The token for the licenses service.\n */\nexport const ILicenses = new Token('@jupyterlite/licenses:ILicenses');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { URLExt, PageConfig } from '@jupyterlab/coreutils';\nimport { THIRD_PARTY_LICENSES, } from './tokens';\n/**\n * An empty bundle.\n */\nconst EMPTY_BUNDLE = Object.freeze({ packages: [] });\n/**\n * A JupyterLite implementation of the jupyterlab_server licenses route\n */\nexport class Licenses {\n    /**\n     * A GET handler for the licenses\n     */\n    async get() {\n        return {\n            bundles: {\n                ...(await this._getFederated()),\n                [this.appName]: await this._getAppLicenses(),\n            },\n        };\n    }\n    /**\n     * Get the app name (or default).\n     */\n    get appName() {\n        return PageConfig.getOption('appName') || 'JupyterLite';\n    }\n    /**\n     * Get the well-known URL of the app licenses.\n     */\n    get appLicensesUrl() {\n        return URLExt.join(PageConfig.getBaseUrl(), 'build', THIRD_PARTY_LICENSES);\n    }\n    /**\n     * Get the lab extension base url.\n     */\n    get labExtensionsUrl() {\n        return PageConfig.getOption('fullLabextensionsUrl');\n    }\n    /**\n     * Resolve the licenses for the app distribution itself, or the empty bundle.\n     */\n    async _getAppLicenses() {\n        let bundle = EMPTY_BUNDLE;\n        try {\n            const response = await fetch(this.appLicensesUrl);\n            bundle = response.json();\n        }\n        catch (err) {\n            console.warn('Could not resolve licenses for', this.appName);\n        }\n        return bundle;\n    }\n    /**\n     * Resolve the licenses for all federated extensions.\n     */\n    async _getFederated() {\n        const bundles = {};\n        let federated;\n        try {\n            federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n        }\n        catch {\n            return bundles;\n        }\n        const promises = [];\n        for (const ext of federated) {\n            promises.push(this._getOneFederated(ext, bundles));\n        }\n        try {\n            await Promise.all(promises);\n        }\n        catch (err) {\n            console.warn('Error resolving licenses', err);\n        }\n        return bundles;\n    }\n    /**\n     * Update the bundles with the extension's licenses, or the empty bundle.\n     */\n    async _getOneFederated(ext, bundles) {\n        try {\n            const url = URLExt.join(this.labExtensionsUrl, ext.name, 'static', THIRD_PARTY_LICENSES);\n            const response = await fetch(url);\n            bundles[ext.name] = await response.json();\n        }\n        catch {\n            console.warn('Could not resolve licenses for', ext);\n            bundles[ext.name] = EMPTY_BUNDLE;\n        }\n    }\n}\n//# sourceMappingURL=licenses.js.map"],"names":["THIRD_PARTY_LICENSES","ILicenses","Token","EMPTY_BUNDLE","Object","freeze","packages","Licenses","get","bundles","this","_getFederated","appName","_getAppLicenses","PageConfig","getOption","appLicensesUrl","URLExt","join","getBaseUrl","labExtensionsUrl","bundle","fetch","json","err","console","warn","federated","JSON","parse","promises","ext","push","_getOneFederated","Promise","all","url","name","response"],"sourceRoot":""}