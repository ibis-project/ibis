{"version":3,"file":"306.b568c30.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lezer/generator/dist/index.js"],"sourcesContent":["import { NodeProp } from '@lezer/common';\nimport { LRParser, LocalTokenGroup } from '@lezer/lr';\n\nclass Node {\n    constructor(start) {\n        this.start = start;\n    }\n}\nclass GrammarDeclaration extends Node {\n    constructor(start, rules, topRules, tokens, localTokens, context, externalTokens, externalSpecializers, externalPropSources, precedences, mainSkip, scopedSkip, dialects, externalProps, autoDelim) {\n        super(start);\n        this.rules = rules;\n        this.topRules = topRules;\n        this.tokens = tokens;\n        this.localTokens = localTokens;\n        this.context = context;\n        this.externalTokens = externalTokens;\n        this.externalSpecializers = externalSpecializers;\n        this.externalPropSources = externalPropSources;\n        this.precedences = precedences;\n        this.mainSkip = mainSkip;\n        this.scopedSkip = scopedSkip;\n        this.dialects = dialects;\n        this.externalProps = externalProps;\n        this.autoDelim = autoDelim;\n    }\n    toString() { return Object.values(this.rules).join(\"\\n\"); }\n}\nclass RuleDeclaration extends Node {\n    constructor(start, id, props, params, expr) {\n        super(start);\n        this.id = id;\n        this.props = props;\n        this.params = params;\n        this.expr = expr;\n    }\n    toString() {\n        return this.id.name + (this.params.length ? `<${this.params.join()}>` : \"\") + \" -> \" + this.expr;\n    }\n}\nclass PrecDeclaration extends Node {\n    constructor(start, items) {\n        super(start);\n        this.items = items;\n    }\n}\nclass TokenPrecDeclaration extends Node {\n    constructor(start, items) {\n        super(start);\n        this.items = items;\n    }\n}\nclass TokenConflictDeclaration extends Node {\n    constructor(start, a, b) {\n        super(start);\n        this.a = a;\n        this.b = b;\n    }\n}\nclass TokenDeclaration extends Node {\n    constructor(start, precedences, conflicts, rules, literals) {\n        super(start);\n        this.precedences = precedences;\n        this.conflicts = conflicts;\n        this.rules = rules;\n        this.literals = literals;\n    }\n}\nclass LocalTokenDeclaration extends Node {\n    constructor(start, precedences, rules, fallback) {\n        super(start);\n        this.precedences = precedences;\n        this.rules = rules;\n        this.fallback = fallback;\n    }\n}\nclass LiteralDeclaration extends Node {\n    constructor(start, literal, props) {\n        super(start);\n        this.literal = literal;\n        this.props = props;\n    }\n}\nclass ContextDeclaration extends Node {\n    constructor(start, id, source) {\n        super(start);\n        this.id = id;\n        this.source = source;\n    }\n}\nclass ExternalTokenDeclaration extends Node {\n    constructor(start, id, source, tokens) {\n        super(start);\n        this.id = id;\n        this.source = source;\n        this.tokens = tokens;\n    }\n}\nclass ExternalSpecializeDeclaration extends Node {\n    constructor(start, type, token, id, source, tokens) {\n        super(start);\n        this.type = type;\n        this.token = token;\n        this.id = id;\n        this.source = source;\n        this.tokens = tokens;\n    }\n}\nclass ExternalPropSourceDeclaration extends Node {\n    constructor(start, id, source) {\n        super(start);\n        this.id = id;\n        this.source = source;\n    }\n}\nclass ExternalPropDeclaration extends Node {\n    constructor(start, id, externalID, source) {\n        super(start);\n        this.id = id;\n        this.externalID = externalID;\n        this.source = source;\n    }\n}\nclass Identifier extends Node {\n    constructor(start, name) {\n        super(start);\n        this.name = name;\n    }\n    toString() { return this.name; }\n}\nclass Expression extends Node {\n    walk(f) { return f(this); }\n    eq(_other) { return false; }\n}\nExpression.prototype.prec = 10;\nclass NameExpression extends Expression {\n    constructor(start, id, args) {\n        super(start);\n        this.id = id;\n        this.args = args;\n    }\n    toString() { return this.id.name + (this.args.length ? `<${this.args.join()}>` : \"\"); }\n    eq(other) {\n        return this.id.name == other.id.name && exprsEq(this.args, other.args);\n    }\n    walk(f) {\n        let args = walkExprs(this.args, f);\n        return f(args == this.args ? this : new NameExpression(this.start, this.id, args));\n    }\n}\nclass SpecializeExpression extends Expression {\n    constructor(start, type, props, token, content) {\n        super(start);\n        this.type = type;\n        this.props = props;\n        this.token = token;\n        this.content = content;\n    }\n    toString() { return `@${this.type}[${this.props.join(\",\")}]<${this.token}, ${this.content}>`; }\n    eq(other) {\n        return this.type == other.type && Prop.eqProps(this.props, other.props) && exprEq(this.token, other.token) &&\n            exprEq(this.content, other.content);\n    }\n    walk(f) {\n        let token = this.token.walk(f), content = this.content.walk(f);\n        return f(token == this.token && content == this.content ? this : new SpecializeExpression(this.start, this.type, this.props, token, content));\n    }\n}\nclass InlineRuleExpression extends Expression {\n    constructor(start, rule) {\n        super(start);\n        this.rule = rule;\n    }\n    toString() {\n        let rule = this.rule;\n        return `${rule.id}${rule.props.length ? `[${rule.props.join(\",\")}]` : \"\"} { ${rule.expr} }`;\n    }\n    eq(other) {\n        let rule = this.rule, oRule = other.rule;\n        return exprEq(rule.expr, oRule.expr) && rule.id.name == oRule.id.name && Prop.eqProps(rule.props, oRule.props);\n    }\n    walk(f) {\n        let rule = this.rule, expr = rule.expr.walk(f);\n        return f(expr == rule.expr ? this :\n            new InlineRuleExpression(this.start, new RuleDeclaration(rule.start, rule.id, rule.props, [], expr)));\n    }\n}\nclass ChoiceExpression extends Expression {\n    constructor(start, exprs) {\n        super(start);\n        this.exprs = exprs;\n    }\n    toString() { return this.exprs.map(e => maybeParens(e, this)).join(\" | \"); }\n    eq(other) {\n        return exprsEq(this.exprs, other.exprs);\n    }\n    walk(f) {\n        let exprs = walkExprs(this.exprs, f);\n        return f(exprs == this.exprs ? this : new ChoiceExpression(this.start, exprs));\n    }\n}\nChoiceExpression.prototype.prec = 1;\nclass SequenceExpression extends Expression {\n    constructor(start, exprs, markers, empty = false) {\n        super(start);\n        this.exprs = exprs;\n        this.markers = markers;\n        this.empty = empty;\n    }\n    toString() { return this.empty ? \"()\" : this.exprs.map(e => maybeParens(e, this)).join(\" \"); }\n    eq(other) {\n        return exprsEq(this.exprs, other.exprs) && this.markers.every((m, i) => {\n            let om = other.markers[i];\n            return m.length == om.length && m.every((x, i) => x.eq(om[i]));\n        });\n    }\n    walk(f) {\n        let exprs = walkExprs(this.exprs, f);\n        return f(exprs == this.exprs ? this : new SequenceExpression(this.start, exprs, this.markers, this.empty && !exprs.length));\n    }\n}\nSequenceExpression.prototype.prec = 2;\nclass ConflictMarker extends Node {\n    constructor(start, id, type) {\n        super(start);\n        this.id = id;\n        this.type = type;\n    }\n    toString() { return (this.type == \"ambig\" ? \"~\" : \"!\") + this.id.name; }\n    eq(other) { return this.id.name == other.id.name && this.type == other.type; }\n}\nclass RepeatExpression extends Expression {\n    constructor(start, expr, kind) {\n        super(start);\n        this.expr = expr;\n        this.kind = kind;\n    }\n    toString() { return maybeParens(this.expr, this) + this.kind; }\n    eq(other) {\n        return exprEq(this.expr, other.expr) && this.kind == other.kind;\n    }\n    walk(f) {\n        let expr = this.expr.walk(f);\n        return f(expr == this.expr ? this : new RepeatExpression(this.start, expr, this.kind));\n    }\n}\nRepeatExpression.prototype.prec = 3;\nclass LiteralExpression extends Expression {\n    // value.length is always > 0\n    constructor(start, value) {\n        super(start);\n        this.value = value;\n    }\n    toString() { return JSON.stringify(this.value); }\n    eq(other) { return this.value == other.value; }\n}\nclass SetExpression extends Expression {\n    constructor(start, ranges, inverted) {\n        super(start);\n        this.ranges = ranges;\n        this.inverted = inverted;\n    }\n    toString() {\n        return `[${this.inverted ? \"^\" : \"\"}${this.ranges.map(([a, b]) => {\n            return String.fromCodePoint(a) + (b == a + 1 ? \"\" : \"-\" + String.fromCodePoint(b));\n        })}]`;\n    }\n    eq(other) {\n        return this.inverted == other.inverted && this.ranges.length == other.ranges.length &&\n            this.ranges.every(([a, b], i) => { let [x, y] = other.ranges[i]; return a == x && b == y; });\n    }\n}\nclass AnyExpression extends Expression {\n    constructor(start) {\n        super(start);\n    }\n    toString() { return \"_\"; }\n    eq() { return true; }\n}\nfunction walkExprs(exprs, f) {\n    let result = null;\n    for (let i = 0; i < exprs.length; i++) {\n        let expr = exprs[i].walk(f);\n        if (expr != exprs[i] && !result)\n            result = exprs.slice(0, i);\n        if (result)\n            result.push(expr);\n    }\n    return result || exprs;\n}\nconst CharClasses = {\n    asciiLetter: [[65, 91], [97, 123]],\n    asciiLowercase: [[97, 123]],\n    asciiUppercase: [[65, 91]],\n    digit: [[48, 58]],\n    whitespace: [[9, 14], [32, 33], [133, 134], [160, 161], [5760, 5761], [8192, 8203],\n        [8232, 8234], [8239, 8240], [8287, 8288], [12288, 12289]],\n    eof: [[0xffff, 0xffff]]\n};\nclass CharClass extends Expression {\n    constructor(start, type) {\n        super(start);\n        this.type = type;\n    }\n    toString() { return \"@\" + this.type; }\n    eq(expr) { return this.type == expr.type; }\n}\nfunction exprEq(a, b) {\n    return a.constructor == b.constructor && a.eq(b);\n}\nfunction exprsEq(a, b) {\n    return a.length == b.length && a.every((e, i) => exprEq(e, b[i]));\n}\nclass Prop extends Node {\n    constructor(start, at, name, value) {\n        super(start);\n        this.at = at;\n        this.name = name;\n        this.value = value;\n    }\n    eq(other) {\n        return this.name == other.name && this.value.length == other.value.length &&\n            this.value.every((v, i) => v.value == other.value[i].value && v.name == other.value[i].name);\n    }\n    toString() {\n        let result = (this.at ? \"@\" : \"\") + this.name;\n        if (this.value.length) {\n            result += \"=\";\n            for (let { name, value } of this.value)\n                result += name ? `{${name}}` : /[^\\w-]/.test(value) ? JSON.stringify(value) : value;\n        }\n        return result;\n    }\n    static eqProps(a, b) {\n        return a.length == b.length && a.every((p, i) => p.eq(b[i]));\n    }\n}\nclass PropPart extends Node {\n    constructor(start, value, name) {\n        super(start);\n        this.value = value;\n        this.name = name;\n    }\n}\nfunction maybeParens(node, parent) {\n    return node.prec < parent.prec ? \"(\" + node.toString() + \")\" : node.toString();\n}\n\n/// The type of error raised when the parser generator finds an issue.\nclass GenError extends Error {\n}\n\nfunction hasProps(props) {\n    for (let _p in props)\n        return true;\n    return false;\n}\nlet termHash = 0;\nclass Term {\n    constructor(name, flags, nodeName, props = {}) {\n        this.name = name;\n        this.flags = flags;\n        this.nodeName = nodeName;\n        this.props = props;\n        this.hash = ++termHash; // Used for sorting and hashing during parser generation\n        this.id = -1; // Assigned in a later stage, used in actual output\n        // Filled in only after the rules are simplified, used in automaton.ts\n        this.rules = [];\n    }\n    toString() { return this.name; }\n    get nodeType() { return this.top || this.nodeName != null || hasProps(this.props) || this.repeated; }\n    get terminal() { return (this.flags & 1 /* TermFlag.Terminal */) > 0; }\n    get eof() { return (this.flags & 4 /* TermFlag.Eof */) > 0; }\n    get error() { return \"error\" in this.props; }\n    get top() { return (this.flags & 2 /* TermFlag.Top */) > 0; }\n    get interesting() { return this.flags > 0 || this.nodeName != null; }\n    get repeated() { return (this.flags & 16 /* TermFlag.Repeated */) > 0; }\n    set preserve(value) { this.flags = value ? this.flags | 8 /* TermFlag.Preserve */ : this.flags & ~8 /* TermFlag.Preserve */; }\n    get preserve() { return (this.flags & 8 /* TermFlag.Preserve */) > 0; }\n    set inline(value) { this.flags = value ? this.flags | 32 /* TermFlag.Inline */ : this.flags & ~32 /* TermFlag.Inline */; }\n    get inline() { return (this.flags & 32 /* TermFlag.Inline */) > 0; }\n    cmp(other) { return this.hash - other.hash; }\n}\nclass TermSet {\n    constructor() {\n        this.terms = [];\n        // Map from term names to Term instances\n        this.names = Object.create(null);\n        this.tops = [];\n        this.eof = this.term(\"\", null, 1 /* TermFlag.Terminal */ | 4 /* TermFlag.Eof */);\n        this.error = this.term(\"\", \"\", 8 /* TermFlag.Preserve */);\n    }\n    term(name, nodeName, flags = 0, props = {}) {\n        let term = new Term(name, flags, nodeName, props);\n        this.terms.push(term);\n        this.names[name] = term;\n        return term;\n    }\n    makeTop(nodeName, props) {\n        const term = this.term(\"@top\", nodeName, 2 /* TermFlag.Top */, props);\n        this.tops.push(term);\n        return term;\n    }\n    makeTerminal(name, nodeName, props = {}) {\n        return this.term(name, nodeName, 1 /* TermFlag.Terminal */, props);\n    }\n    makeNonTerminal(name, nodeName, props = {}) {\n        return this.term(name, nodeName, 0, props);\n    }\n    makeRepeat(name) {\n        return this.term(name, null, 16 /* TermFlag.Repeated */);\n    }\n    uniqueName(name) {\n        for (let i = 0;; i++) {\n            let cur = i ? `${name}-${i}` : name;\n            if (!this.names[cur])\n                return cur;\n        }\n    }\n    finish(rules) {\n        for (let rule of rules)\n            rule.name.rules.push(rule);\n        this.terms = this.terms.filter(t => t.terminal || t.preserve || rules.some(r => r.name == t || r.parts.includes(t)));\n        let names = {};\n        let nodeTypes = [this.error];\n        this.error.id = 0 /* T.Err */;\n        let nextID = 0 /* T.Err */ + 1;\n        // Assign ids to terms that represent node types\n        for (let term of this.terms)\n            if (term.id < 0 && term.nodeType && !term.repeated) {\n                term.id = nextID++;\n                nodeTypes.push(term);\n            }\n        // Put all repeated terms after the regular node types\n        let minRepeatTerm = nextID;\n        for (let term of this.terms)\n            if (term.repeated) {\n                term.id = nextID++;\n                nodeTypes.push(term);\n            }\n        // Then comes the EOF term\n        this.eof.id = nextID++;\n        // And then the remaining (non-node, non-repeat) terms.\n        for (let term of this.terms) {\n            if (term.id < 0)\n                term.id = nextID++;\n            if (term.name)\n                names[term.id] = term.name;\n        }\n        if (nextID >= 0xfffe)\n            throw new GenError(\"Too many terms\");\n        return { nodeTypes, names, minRepeatTerm, maxTerm: nextID - 1 };\n    }\n}\nfunction cmpSet(a, b, cmp) {\n    if (a.length != b.length)\n        return a.length - b.length;\n    for (let i = 0; i < a.length; i++) {\n        let diff = cmp(a[i], b[i]);\n        if (diff)\n            return diff;\n    }\n    return 0;\n}\nconst none$3 = [];\nclass Conflicts {\n    constructor(precedence, ambigGroups = none$3, cut = 0) {\n        this.precedence = precedence;\n        this.ambigGroups = ambigGroups;\n        this.cut = cut;\n    }\n    join(other) {\n        if (this == Conflicts.none || this == other)\n            return other;\n        if (other == Conflicts.none)\n            return this;\n        return new Conflicts(Math.max(this.precedence, other.precedence), union(this.ambigGroups, other.ambigGroups), Math.max(this.cut, other.cut));\n    }\n    cmp(other) {\n        return this.precedence - other.precedence || cmpSet(this.ambigGroups, other.ambigGroups, (a, b) => a < b ? -1 : a > b ? 1 : 0) ||\n            this.cut - other.cut;\n    }\n}\nConflicts.none = new Conflicts(0);\nfunction union(a, b) {\n    if (a.length == 0 || a == b)\n        return b;\n    if (b.length == 0)\n        return a;\n    let result = a.slice();\n    for (let value of b)\n        if (!a.includes(value))\n            result.push(value);\n    return result.sort();\n}\nlet ruleID = 0;\nclass Rule {\n    constructor(name, parts, conflicts, skip) {\n        this.name = name;\n        this.parts = parts;\n        this.conflicts = conflicts;\n        this.skip = skip;\n        this.id = ruleID++;\n    }\n    cmp(rule) {\n        return this.id - rule.id;\n    }\n    cmpNoName(rule) {\n        return this.parts.length - rule.parts.length ||\n            this.skip.hash - rule.skip.hash ||\n            this.parts.reduce((r, s, i) => r || s.cmp(rule.parts[i]), 0) ||\n            cmpSet(this.conflicts, rule.conflicts, (a, b) => a.cmp(b));\n    }\n    toString() {\n        return this.name + \" -> \" + this.parts.join(\" \");\n    }\n    get isRepeatWrap() {\n        return this.name.repeated && this.parts.length == 2 && this.parts[0] == this.name;\n    }\n    sameReduce(other) {\n        return this.name == other.name && this.parts.length == other.parts.length && this.isRepeatWrap == other.isRepeatWrap;\n    }\n}\n\nconst MAX_CHAR = 0xffff;\nclass Edge {\n    constructor(from, to, target) {\n        this.from = from;\n        this.to = to;\n        this.target = target;\n    }\n    toString() {\n        return `-> ${this.target.id}[label=${JSON.stringify(this.from < 0 ? \"\" : charFor(this.from) +\n            (this.to > this.from + 1 ? \"-\" + charFor(this.to - 1) : \"\"))}]`;\n    }\n}\nfunction charFor(n) {\n    return n > MAX_CHAR ? \"\"\n        : n == 10 ? \"\\\\n\"\n            : n == 13 ? \"\\\\r\"\n                : n < 32 || n >= 0xd800 && n < 0xdfff ? \"\\\\u{\" + n.toString(16) + \"}\"\n                    : String.fromCharCode(n);\n}\nfunction minimize(states, start) {\n    let partition = Object.create(null);\n    let byAccepting = Object.create(null);\n    for (let state of states) {\n        let id = ids(state.accepting);\n        let group = byAccepting[id] || (byAccepting[id] = []);\n        group.push(state);\n        partition[state.id] = group;\n    }\n    for (;;) {\n        let split = false, newPartition = Object.create(null);\n        for (let state of states) {\n            if (newPartition[state.id])\n                continue;\n            let group = partition[state.id];\n            if (group.length == 1) {\n                newPartition[group[0].id] = group;\n                continue;\n            }\n            let parts = [];\n            groups: for (let state of group) {\n                for (let p of parts) {\n                    if (isEquivalent(state, p[0], partition)) {\n                        p.push(state);\n                        continue groups;\n                    }\n                }\n                parts.push([state]);\n            }\n            if (parts.length > 1)\n                split = true;\n            for (let p of parts)\n                for (let s of p)\n                    newPartition[s.id] = p;\n        }\n        if (!split)\n            return applyMinimization(states, start, partition);\n        partition = newPartition;\n    }\n}\nfunction isEquivalent(a, b, partition) {\n    if (a.edges.length != b.edges.length)\n        return false;\n    for (let i = 0; i < a.edges.length; i++) {\n        let eA = a.edges[i], eB = b.edges[i];\n        if (eA.from != eB.from || eA.to != eB.to || partition[eA.target.id] != partition[eB.target.id])\n            return false;\n    }\n    return true;\n}\nfunction applyMinimization(states, start, partition) {\n    for (let state of states) {\n        for (let i = 0; i < state.edges.length; i++) {\n            let edge = state.edges[i], target = partition[edge.target.id][0];\n            if (target != edge.target)\n                state.edges[i] = new Edge(edge.from, edge.to, target);\n        }\n    }\n    return partition[start.id][0];\n}\nlet stateID = 1;\nclass State$1 {\n    constructor(accepting = [], id = stateID++) {\n        this.accepting = accepting;\n        this.id = id;\n        this.edges = [];\n    }\n    edge(from, to, target) {\n        this.edges.push(new Edge(from, to, target));\n    }\n    nullEdge(target) { this.edge(-1, -1, target); }\n    compile() {\n        let labeled = Object.create(null), localID = 0;\n        let startState = explore(this.closure().sort((a, b) => a.id - b.id));\n        return minimize(Object.values(labeled), startState);\n        function explore(states) {\n            let newState = labeled[ids(states)] =\n                new State$1(states.reduce((a, s) => union(a, s.accepting), []), localID++);\n            let out = [];\n            for (let state of states)\n                for (let edge of state.edges) {\n                    if (edge.from >= 0)\n                        out.push(edge);\n                }\n            let transitions = mergeEdges(out);\n            for (let merged of transitions) {\n                let targets = merged.targets.sort((a, b) => a.id - b.id);\n                newState.edge(merged.from, merged.to, labeled[ids(targets)] || explore(targets));\n            }\n            return newState;\n        }\n    }\n    closure() {\n        let result = [], seen = Object.create(null);\n        function explore(state) {\n            if (seen[state.id])\n                return;\n            seen[state.id] = true;\n            // States with only epsilon edges and no accepting term that\n            // isn't also in the next states are left out to help reduce the\n            // number of unique state combinations\n            if (state.edges.some(e => e.from >= 0) ||\n                (state.accepting.length > 0 && !state.edges.some(e => sameSet$1(state.accepting, e.target.accepting))))\n                result.push(state);\n            for (let edge of state.edges)\n                if (edge.from < 0)\n                    explore(edge.target);\n        }\n        explore(this);\n        return result;\n    }\n    findConflicts(occurTogether) {\n        let conflicts = [], cycleTerms = this.cycleTerms();\n        function add(a, b, soft, aEdges, bEdges) {\n            if (a.id < b.id) {\n                [a, b] = [b, a];\n                soft = -soft;\n            }\n            let found = conflicts.find(c => c.a == a && c.b == b);\n            if (!found)\n                conflicts.push(new Conflict$1(a, b, soft, exampleFromEdges(aEdges), bEdges && exampleFromEdges(bEdges)));\n            else if (found.soft != soft)\n                found.soft = 0;\n        }\n        this.reachable((state, edges) => {\n            if (state.accepting.length == 0)\n                return;\n            for (let i = 0; i < state.accepting.length; i++)\n                for (let j = i + 1; j < state.accepting.length; j++)\n                    add(state.accepting[i], state.accepting[j], 0, edges);\n            state.reachable((s, es) => {\n                if (s != state)\n                    for (let term of s.accepting) {\n                        let hasCycle = cycleTerms.includes(term);\n                        for (let orig of state.accepting)\n                            if (term != orig)\n                                add(term, orig, hasCycle || cycleTerms.includes(orig) || !occurTogether(term, orig) ? 0 : 1, edges, edges.concat(es));\n                    }\n            });\n        });\n        return conflicts;\n    }\n    cycleTerms() {\n        let work = [];\n        this.reachable(state => {\n            for (let { target } of state.edges)\n                work.push(state, target);\n        });\n        let table = new Map;\n        let haveCycle = [];\n        for (let i = 0; i < work.length;) {\n            let from = work[i++], to = work[i++];\n            let entry = table.get(from);\n            if (!entry)\n                table.set(from, entry = []);\n            if (entry.includes(to))\n                continue;\n            if (from == to) {\n                if (!haveCycle.includes(from))\n                    haveCycle.push(from);\n            }\n            else {\n                for (let next of entry)\n                    work.push(from, next);\n                entry.push(to);\n            }\n        }\n        let result = [];\n        for (let state of haveCycle) {\n            for (let term of state.accepting) {\n                if (!result.includes(term))\n                    result.push(term);\n            }\n        }\n        return result;\n    }\n    reachable(f) {\n        let seen = [], edges = [];\n        (function explore(s) {\n            f(s, edges);\n            seen.push(s);\n            for (let edge of s.edges)\n                if (!seen.includes(edge.target)) {\n                    edges.push(edge);\n                    explore(edge.target);\n                    edges.pop();\n                }\n        })(this);\n    }\n    toString() {\n        let out = \"digraph {\\n\";\n        this.reachable(state => {\n            if (state.accepting.length)\n                out += `  ${state.id} [label=${JSON.stringify(state.accepting.join())}];\\n`;\n            for (let edge of state.edges)\n                out += `  ${state.id} ${edge};\\n`;\n        });\n        return out + \"}\";\n    }\n    // Tokenizer data is represented as a single flat array. This\n    // contains regions for each tokenizer state. Region offsets are\n    // used to identify states.\n    //\n    // Each state is laid out as:\n    //  - Token group mask\n    //  - Offset of the end of the accepting data\n    //  - Number of outgoing edges in the state\n    //  - Pairs of token masks and term ids that indicate the accepting\n    //    states, sorted by precedence\n    //  - Triples for the edges: each with a low and high bound and the\n    //    offset of the next state.\n    toArray(groupMasks, precedence) {\n        let offsets = []; // Used to 'link' the states after building the arrays\n        let data = [];\n        this.reachable(state => {\n            let start = data.length;\n            let acceptEnd = start + 3 + state.accepting.length * 2;\n            offsets[state.id] = start;\n            data.push(state.stateMask(groupMasks), acceptEnd, state.edges.length);\n            state.accepting.sort((a, b) => precedence.indexOf(a.id) - precedence.indexOf(b.id));\n            for (let term of state.accepting)\n                data.push(term.id, groupMasks[term.id] || 0xffff);\n            for (let edge of state.edges)\n                data.push(edge.from, edge.to, -edge.target.id - 1);\n        });\n        // Replace negative numbers with resolved state offsets\n        for (let i = 0; i < data.length; i++)\n            if (data[i] < 0)\n                data[i] = offsets[-data[i] - 1];\n        if (data.length > 2 ** 16)\n            throw new GenError(\"Tokenizer tables too big to represent with 16-bit offsets.\");\n        return Uint16Array.from(data);\n    }\n    stateMask(groupMasks) {\n        let mask = 0;\n        this.reachable(state => {\n            for (let term of state.accepting)\n                mask |= (groupMasks[term.id] || 0xffff);\n        });\n        return mask;\n    }\n}\nclass Conflict$1 {\n    constructor(a, b, \n    // Conflicts between two non-cyclic tokens are marked as\n    // 'soft', with a negative number if a is shorter than\n    // b, and a positive if b is shorter than a.\n    soft, exampleA, exampleB) {\n        this.a = a;\n        this.b = b;\n        this.soft = soft;\n        this.exampleA = exampleA;\n        this.exampleB = exampleB;\n    }\n}\nfunction exampleFromEdges(edges) {\n    let str = \"\";\n    for (let i = 0; i < edges.length; i++)\n        str += String.fromCharCode(edges[i].from);\n    return str;\n}\nfunction ids(elts) {\n    let result = \"\";\n    for (let elt of elts) {\n        if (result.length)\n            result += \"-\";\n        result += elt.id;\n    }\n    return result;\n}\nfunction sameSet$1(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i])\n            return false;\n    return true;\n}\nclass MergedEdge {\n    constructor(from, to, targets) {\n        this.from = from;\n        this.to = to;\n        this.targets = targets;\n    }\n}\n// Merge multiple edges (tagged by character ranges) into a set of\n// mutually exclusive ranges pointing at all target states for that\n// range\nfunction mergeEdges(edges) {\n    let separate = [], result = [];\n    for (let edge of edges) {\n        if (!separate.includes(edge.from))\n            separate.push(edge.from);\n        if (!separate.includes(edge.to))\n            separate.push(edge.to);\n    }\n    separate.sort((a, b) => a - b);\n    for (let i = 1; i < separate.length; i++) {\n        let from = separate[i - 1], to = separate[i];\n        let found = [];\n        for (let edge of edges)\n            if (edge.to > from && edge.from < to) {\n                for (let target of edge.target.closure())\n                    if (!found.includes(target))\n                        found.push(target);\n            }\n        if (found.length)\n            result.push(new MergedEdge(from, to, found));\n    }\n    let eof = edges.filter(e => e.from == 65535 /* Seq.End */ && e.to == 65535 /* Seq.End */);\n    if (eof.length) {\n        let found = [];\n        for (let edge of eof)\n            for (let target of edge.target.closure())\n                if (!found.includes(target))\n                    found.push(target);\n        if (found.length)\n            result.push(new MergedEdge(65535 /* Seq.End */, 65535 /* Seq.End */, found));\n    }\n    return result;\n}\n\n// Note that this is the parser for grammar files, not the generated parser\nlet word = /[\\w_-]+/gy;\n// Some engines (specifically SpiderMonkey) have still not implemented \\p\ntry {\n    word = /[\\p{Alphabetic}\\d_-]+/ugy;\n}\ncatch (_) { }\nconst none$2 = [];\nclass Input {\n    constructor(string, fileName = null) {\n        this.string = string;\n        this.fileName = fileName;\n        this.type = \"sof\";\n        this.value = null;\n        this.start = 0;\n        this.end = 0;\n        this.next();\n    }\n    lineInfo(pos) {\n        for (let line = 1, cur = 0;;) {\n            let next = this.string.indexOf(\"\\n\", cur);\n            if (next > -1 && next < pos) {\n                ++line;\n                cur = next + 1;\n            }\n            else {\n                return { line, ch: pos - cur };\n            }\n        }\n    }\n    message(msg, pos = -1) {\n        let posInfo = this.fileName || \"\";\n        if (pos > -1) {\n            let info = this.lineInfo(pos);\n            posInfo += (posInfo ? \" \" : \"\") + info.line + \":\" + info.ch;\n        }\n        return posInfo ? msg + ` (${posInfo})` : msg;\n    }\n    raise(msg, pos = -1) {\n        throw new GenError(this.message(msg, pos));\n    }\n    match(pos, re) {\n        let match = re.exec(this.string.slice(pos));\n        return match ? pos + match[0].length : -1;\n    }\n    next() {\n        let start = this.match(this.end, /^(\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n        if (start == this.string.length)\n            return this.set(\"eof\", null, start, start);\n        let next = this.string[start];\n        if (next == '\"') {\n            let end = this.match(start + 1, /^(\\\\.|[^\"\\\\])*\"/);\n            if (end == -1)\n                this.raise(\"Unterminated string literal\", start);\n            return this.set(\"string\", readString(this.string.slice(start + 1, end - 1)), start, end);\n        }\n        else if (next == \"'\") {\n            let end = this.match(start + 1, /^(\\\\.|[^'\\\\])*'/);\n            if (end == -1)\n                this.raise(\"Unterminated string literal\", start);\n            return this.set(\"string\", readString(this.string.slice(start + 1, end - 1)), start, end);\n        }\n        else if (next == \"@\") {\n            word.lastIndex = start + 1;\n            let m = word.exec(this.string);\n            if (!m)\n                return this.raise(\"@ without a name\", start);\n            return this.set(\"at\", m[0], start, start + 1 + m[0].length);\n        }\n        else if ((next == \"$\" || next == \"!\") && this.string[start + 1] == \"[\") {\n            let end = this.match(start + 2, /^(?:\\\\.|[^\\]\\\\])*\\]/);\n            if (end == -1)\n                this.raise(\"Unterminated character set\", start);\n            return this.set(\"set\", this.string.slice(start + 2, end - 1), start, end);\n        }\n        else if (/[\\[\\]()!~+*?{}<>\\.,|:$=]/.test(next)) {\n            return this.set(next, null, start, start + 1);\n        }\n        else {\n            word.lastIndex = start;\n            let m = word.exec(this.string);\n            if (!m)\n                return this.raise(\"Unexpected character \" + JSON.stringify(next), start);\n            return this.set(\"id\", m[0], start, start + m[0].length);\n        }\n    }\n    set(type, value, start, end) {\n        this.type = type;\n        this.value = value;\n        this.start = start;\n        this.end = end;\n    }\n    eat(type, value = null) {\n        if (this.type == type && (value == null || this.value === value)) {\n            this.next();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    unexpected() {\n        return this.raise(`Unexpected token '${this.string.slice(this.start, this.end)}'`, this.start);\n    }\n    expect(type, value = null) {\n        let val = this.value;\n        if (this.type != type || !(value == null || val === value))\n            this.unexpected();\n        this.next();\n        return val;\n    }\n    parse() {\n        return parseGrammar(this);\n    }\n}\nfunction parseGrammar(input) {\n    let start = input.start;\n    let rules = [];\n    let prec = null;\n    let tokens = null;\n    let localTokens = [];\n    let mainSkip = null;\n    let scopedSkip = [];\n    let dialects = [];\n    let context = null;\n    let external = [];\n    let specialized = [];\n    let props = [];\n    let propSources = [];\n    let tops = [];\n    let sawTop = false;\n    let autoDelim = false;\n    while (input.type != \"eof\") {\n        let start = input.start;\n        if (input.eat(\"at\", \"top\")) {\n            if (input.type != \"id\")\n                input.raise(`Top rules must have a name`, input.start);\n            tops.push(parseRule(input, parseIdent(input)));\n            sawTop = true;\n        }\n        else if (input.type == \"at\" && input.value == \"tokens\") {\n            if (tokens)\n                input.raise(`Multiple @tokens declaractions`, input.start);\n            else\n                tokens = parseTokens(input);\n        }\n        else if (input.eat(\"at\", \"local\")) {\n            input.expect(\"id\", \"tokens\");\n            localTokens.push(parseLocalTokens(input, start));\n        }\n        else if (input.eat(\"at\", \"context\")) {\n            if (context)\n                input.raise(`Multiple @context declarations`, start);\n            let id = parseIdent(input);\n            input.expect(\"id\", \"from\");\n            let source = input.expect(\"string\");\n            context = new ContextDeclaration(start, id, source);\n        }\n        else if (input.eat(\"at\", \"external\")) {\n            if (input.eat(\"id\", \"tokens\"))\n                external.push(parseExternalTokens(input, start));\n            else if (input.eat(\"id\", \"prop\"))\n                props.push(parseExternalProp(input, start));\n            else if (input.eat(\"id\", \"extend\"))\n                specialized.push(parseExternalSpecialize(input, \"extend\", start));\n            else if (input.eat(\"id\", \"specialize\"))\n                specialized.push(parseExternalSpecialize(input, \"specialize\", start));\n            else if (input.eat(\"id\", \"propSource\"))\n                propSources.push(parseExternalPropSource(input, start));\n            else\n                input.unexpected();\n        }\n        else if (input.eat(\"at\", \"dialects\")) {\n            input.expect(\"{\");\n            for (let first = true; !input.eat(\"}\"); first = false) {\n                if (!first)\n                    input.eat(\",\");\n                dialects.push(parseIdent(input));\n            }\n        }\n        else if (input.type == \"at\" && input.value == \"precedence\") {\n            if (prec)\n                input.raise(`Multiple precedence declarations`, input.start);\n            prec = parsePrecedence(input);\n        }\n        else if (input.eat(\"at\", \"detectDelim\")) {\n            autoDelim = true;\n        }\n        else if (input.eat(\"at\", \"skip\")) {\n            let skip = parseBracedExpr(input);\n            if (input.type == \"{\") {\n                input.next();\n                let rules = [], topRules = [];\n                while (!input.eat(\"}\")) {\n                    if (input.eat(\"at\", \"top\")) {\n                        topRules.push(parseRule(input, parseIdent(input)));\n                        sawTop = true;\n                    }\n                    else {\n                        rules.push(parseRule(input));\n                    }\n                }\n                scopedSkip.push({ expr: skip, topRules, rules });\n            }\n            else {\n                if (mainSkip)\n                    input.raise(`Multiple top-level skip declarations`, input.start);\n                mainSkip = skip;\n            }\n        }\n        else {\n            rules.push(parseRule(input));\n        }\n    }\n    if (!sawTop)\n        return input.raise(`Missing @top declaration`);\n    return new GrammarDeclaration(start, rules, tops, tokens, localTokens, context, external, specialized, propSources, prec, mainSkip, scopedSkip, dialects, props, autoDelim);\n}\nfunction parseRule(input, named) {\n    let start = named ? named.start : input.start;\n    let id = named || parseIdent(input);\n    let props = parseProps(input);\n    let params = [];\n    if (input.eat(\"<\"))\n        while (!input.eat(\">\")) {\n            if (params.length)\n                input.expect(\",\");\n            params.push(parseIdent(input));\n        }\n    let expr = parseBracedExpr(input);\n    return new RuleDeclaration(start, id, props, params, expr);\n}\nfunction parseProps(input) {\n    if (input.type != \"[\")\n        return none$2;\n    let props = [];\n    input.expect(\"[\");\n    while (!input.eat(\"]\")) {\n        if (props.length)\n            input.expect(\",\");\n        props.push(parseProp(input));\n    }\n    return props;\n}\nfunction parseProp(input) {\n    let start = input.start, value = [], name = input.value, at = input.type == \"at\";\n    if (!input.eat(\"at\") && !input.eat(\"id\"))\n        input.unexpected();\n    if (input.eat(\"=\"))\n        for (;;) {\n            if (input.type == \"string\" || input.type == \"id\") {\n                value.push(new PropPart(input.start, input.value, null));\n                input.next();\n            }\n            else if (input.eat(\".\")) {\n                value.push(new PropPart(input.start, \".\", null));\n            }\n            else if (input.eat(\"{\")) {\n                value.push(new PropPart(input.start, null, input.expect(\"id\")));\n                input.expect(\"}\");\n            }\n            else {\n                break;\n            }\n        }\n    return new Prop(start, at, name, value);\n}\nfunction parseBracedExpr(input) {\n    input.expect(\"{\");\n    let expr = parseExprChoice(input);\n    input.expect(\"}\");\n    return expr;\n}\nconst SET_MARKER = \"\\ufdda\"; // (Invalid unicode character)\nfunction parseExprInner(input) {\n    let start = input.start;\n    if (input.eat(\"(\")) {\n        if (input.eat(\")\"))\n            return new SequenceExpression(start, none$2, [none$2, none$2]);\n        let expr = parseExprChoice(input);\n        input.expect(\")\");\n        return expr;\n    }\n    else if (input.type == \"string\") {\n        let value = input.value;\n        input.next();\n        if (value.length == 0)\n            return new SequenceExpression(start, none$2, [none$2, none$2]);\n        return new LiteralExpression(start, value);\n    }\n    else if (input.eat(\"id\", \"_\")) {\n        return new AnyExpression(start);\n    }\n    else if (input.type == \"set\") {\n        let content = input.value, invert = input.string[input.start] == \"!\";\n        let unescaped = readString(content.replace(/\\\\.|-|\"/g, (m) => {\n            return m == \"-\" ? SET_MARKER : m == '\"' ? '\\\\\"' : m;\n        }));\n        let ranges = [];\n        for (let pos = 0; pos < unescaped.length;) {\n            let code = unescaped.codePointAt(pos);\n            pos += code > 0xffff ? 2 : 1;\n            if (pos < unescaped.length - 1 && unescaped[pos] == SET_MARKER) {\n                let end = unescaped.codePointAt(pos + 1);\n                pos += end > 0xffff ? 3 : 2;\n                if (end < code)\n                    input.raise(\"Invalid character range\", input.start);\n                addRange(input, ranges, code, end + 1);\n            }\n            else {\n                if (code == SET_MARKER.charCodeAt(0))\n                    code = 45;\n                addRange(input, ranges, code, code + 1);\n            }\n        }\n        input.next();\n        return new SetExpression(start, ranges.sort((a, b) => a[0] - b[0]), invert);\n    }\n    else if (input.type == \"at\" && (input.value == \"specialize\" || input.value == \"extend\")) {\n        let { start, value } = input;\n        input.next();\n        let props = parseProps(input);\n        input.expect(\"<\");\n        let token = parseExprChoice(input), content;\n        if (input.eat(\",\")) {\n            content = parseExprChoice(input);\n        }\n        else if (token instanceof LiteralExpression) {\n            content = token;\n        }\n        else {\n            input.raise(`@${value} requires two arguments when its first argument isn't a literal string`);\n        }\n        input.expect(\">\");\n        return new SpecializeExpression(start, value, props, token, content);\n    }\n    else if (input.type == \"at\" && CharClasses.hasOwnProperty(input.value)) {\n        let cls = new CharClass(input.start, input.value);\n        input.next();\n        return cls;\n    }\n    else if (input.type == \"[\") {\n        let rule = parseRule(input, new Identifier(start, \"_anon\"));\n        if (rule.params.length)\n            input.raise(`Inline rules can't have parameters`, rule.start);\n        return new InlineRuleExpression(start, rule);\n    }\n    else {\n        let id = parseIdent(input);\n        if (input.type == \"[\" || input.type == \"{\") {\n            let rule = parseRule(input, id);\n            if (rule.params.length)\n                input.raise(`Inline rules can't have parameters`, rule.start);\n            return new InlineRuleExpression(start, rule);\n        }\n        else {\n            if (input.eat(\".\") && id.name == \"std\" && CharClasses.hasOwnProperty(input.value)) {\n                let cls = new CharClass(start, input.value);\n                input.next();\n                return cls;\n            }\n            return new NameExpression(start, id, parseArgs(input));\n        }\n    }\n}\nfunction parseArgs(input) {\n    let args = [];\n    if (input.eat(\"<\"))\n        while (!input.eat(\">\")) {\n            if (args.length)\n                input.expect(\",\");\n            args.push(parseExprChoice(input));\n        }\n    return args;\n}\nfunction addRange(input, ranges, from, to) {\n    if (!ranges.every(([a, b]) => b <= from || a >= to))\n        input.raise(\"Overlapping character range\", input.start);\n    ranges.push([from, to]);\n}\nfunction parseExprSuffix(input) {\n    let start = input.start;\n    let expr = parseExprInner(input);\n    for (;;) {\n        let kind = input.type;\n        if (input.eat(\"*\") || input.eat(\"?\") || input.eat(\"+\"))\n            expr = new RepeatExpression(start, expr, kind);\n        else\n            return expr;\n    }\n}\nfunction endOfSequence(input) {\n    return input.type == \"}\" || input.type == \")\" || input.type == \"|\" || input.type == \"/\" ||\n        input.type == \"/\\\\\" || input.type == \"{\" || input.type == \",\" || input.type == \">\";\n}\nfunction parseExprSequence(input) {\n    let start = input.start, exprs = [], markers = [none$2];\n    do {\n        // Add markers at this position\n        for (;;) {\n            let localStart = input.start, markerType;\n            if (input.eat(\"~\"))\n                markerType = \"ambig\";\n            else if (input.eat(\"!\"))\n                markerType = \"prec\";\n            else\n                break;\n            markers[markers.length - 1] =\n                markers[markers.length - 1].concat(new ConflictMarker(localStart, parseIdent(input), markerType));\n        }\n        if (endOfSequence(input))\n            break;\n        exprs.push(parseExprSuffix(input));\n        markers.push(none$2);\n    } while (!endOfSequence(input));\n    if (exprs.length == 1 && markers.every(ms => ms.length == 0))\n        return exprs[0];\n    return new SequenceExpression(start, exprs, markers, !exprs.length);\n}\nfunction parseExprChoice(input) {\n    let start = input.start, left = parseExprSequence(input);\n    if (!input.eat(\"|\"))\n        return left;\n    let exprs = [left];\n    do {\n        exprs.push(parseExprSequence(input));\n    } while (input.eat(\"|\"));\n    let empty = exprs.find(s => s instanceof SequenceExpression && s.empty);\n    if (empty)\n        input.raise(\"Empty expression in choice operator. If this is intentional, use () to make it explicit.\", empty.start);\n    return new ChoiceExpression(start, exprs);\n}\nfunction parseIdent(input) {\n    if (input.type != \"id\")\n        input.unexpected();\n    let start = input.start, name = input.value;\n    input.next();\n    return new Identifier(start, name);\n}\nfunction parsePrecedence(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let items = [];\n    while (!input.eat(\"}\")) {\n        if (items.length)\n            input.eat(\",\");\n        items.push({\n            id: parseIdent(input),\n            type: input.eat(\"at\", \"left\") ? \"left\" : input.eat(\"at\", \"right\") ? \"right\" : input.eat(\"at\", \"cut\") ? \"cut\" : null\n        });\n    }\n    return new PrecDeclaration(start, items);\n}\nfunction parseTokens(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let tokenRules = [];\n    let literals = [];\n    let precedences = [];\n    let conflicts = [];\n    while (!input.eat(\"}\")) {\n        if (input.type == \"at\" && input.value == \"precedence\") {\n            precedences.push(parseTokenPrecedence(input));\n        }\n        else if (input.type == \"at\" && input.value == \"conflict\") {\n            conflicts.push(parseTokenConflict(input));\n        }\n        else if (input.type == \"string\") {\n            literals.push(new LiteralDeclaration(input.start, input.expect(\"string\"), parseProps(input)));\n        }\n        else {\n            tokenRules.push(parseRule(input));\n        }\n    }\n    return new TokenDeclaration(start, precedences, conflicts, tokenRules, literals);\n}\nfunction parseLocalTokens(input, start) {\n    input.expect(\"{\");\n    let tokenRules = [];\n    let precedences = [];\n    let fallback = null;\n    while (!input.eat(\"}\")) {\n        if (input.type == \"at\" && input.value == \"precedence\") {\n            precedences.push(parseTokenPrecedence(input));\n        }\n        else if (input.eat(\"at\", \"else\") && !fallback) {\n            fallback = { id: parseIdent(input), props: parseProps(input) };\n        }\n        else {\n            tokenRules.push(parseRule(input));\n        }\n    }\n    return new LocalTokenDeclaration(start, precedences, tokenRules, fallback);\n}\nfunction parseTokenPrecedence(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let tokens = [];\n    while (!input.eat(\"}\")) {\n        if (tokens.length)\n            input.eat(\",\");\n        let expr = parseExprInner(input);\n        if (expr instanceof LiteralExpression || expr instanceof NameExpression)\n            tokens.push(expr);\n        else\n            input.raise(`Invalid expression in token precedences`, expr.start);\n    }\n    return new TokenPrecDeclaration(start, tokens);\n}\nfunction parseTokenConflict(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let a = parseExprInner(input);\n    if (!(a instanceof LiteralExpression || a instanceof NameExpression))\n        input.raise(`Invalid expression in token conflict`, a.start);\n    input.eat(\",\");\n    let b = parseExprInner(input);\n    if (!(b instanceof LiteralExpression || b instanceof NameExpression))\n        input.raise(`Invalid expression in token conflict`, b.start);\n    input.expect(\"}\");\n    return new TokenConflictDeclaration(start, a, b);\n}\nfunction parseExternalTokenSet(input) {\n    let tokens = [];\n    input.expect(\"{\");\n    while (!input.eat(\"}\")) {\n        if (tokens.length)\n            input.eat(\",\");\n        let id = parseIdent(input);\n        let props = parseProps(input);\n        tokens.push({ id, props });\n    }\n    return tokens;\n}\nfunction parseExternalTokens(input, start) {\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalTokenDeclaration(start, id, from, parseExternalTokenSet(input));\n}\nfunction parseExternalSpecialize(input, type, start) {\n    let token = parseBracedExpr(input);\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalSpecializeDeclaration(start, type, token, id, from, parseExternalTokenSet(input));\n}\nfunction parseExternalPropSource(input, start) {\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    return new ExternalPropSourceDeclaration(start, id, input.expect(\"string\"));\n}\nfunction parseExternalProp(input, start) {\n    let externalID = parseIdent(input);\n    let id = input.eat(\"id\", \"as\") ? parseIdent(input) : externalID;\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalPropDeclaration(start, id, externalID, from);\n}\nfunction readString(string) {\n    let point = /\\\\(?:u\\{([\\da-f]+)\\}|u([\\da-f]{4})|x([\\da-f]{2})|([ntbrf0])|(.))|[^]/yig;\n    let out = \"\", m;\n    while (m = point.exec(string)) {\n        let [all, u1, u2, u3, single, unknown] = m;\n        if (u1 || u2 || u3)\n            out += String.fromCodePoint(parseInt(u1 || u2 || u3, 16));\n        else if (single)\n            out += single == \"n\" ? \"\\n\" : single == \"t\" ? \"\\t\" : single == \"0\" ? \"\\0\" : single == \"r\" ? \"\\r\" : single == \"f\" ? \"\\f\" : \"\\b\";\n        else if (unknown)\n            out += unknown;\n        else\n            out += all;\n    }\n    return out;\n}\n\nfunction hash(a, b) { return (a << 5) + a + b; }\nfunction hashString(h, s) {\n    for (let i = 0; i < s.length; i++)\n        h = hash(h, s.charCodeAt(i));\n    return h;\n}\n\nconst verbose = (typeof process != \"undefined\" && process.env.LOG) || \"\";\nconst timing = /\\btime\\b/.test(verbose);\nconst time = timing ? (label, f) => {\n    let t0 = Date.now();\n    let result = f();\n    console.log(`${label} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n    return result;\n} : (_label, f) => f();\n\nclass Pos {\n    constructor(rule, pos, \n    // NOTE `ahead` and `ambigAhead` aren't mutated anymore after `finish()` has been called\n    ahead, ambigAhead, skipAhead, via) {\n        this.rule = rule;\n        this.pos = pos;\n        this.ahead = ahead;\n        this.ambigAhead = ambigAhead;\n        this.skipAhead = skipAhead;\n        this.via = via;\n        this.hash = 0;\n    }\n    finish() {\n        let h = hash(hash(this.rule.id, this.pos), this.skipAhead.hash);\n        for (let a of this.ahead)\n            h = hash(h, a.hash);\n        for (let group of this.ambigAhead)\n            h = hashString(h, group);\n        this.hash = h;\n        return this;\n    }\n    get next() {\n        return this.pos < this.rule.parts.length ? this.rule.parts[this.pos] : null;\n    }\n    advance() {\n        return new Pos(this.rule, this.pos + 1, this.ahead, this.ambigAhead, this.skipAhead, this.via).finish();\n    }\n    get skip() {\n        return this.pos == this.rule.parts.length ? this.skipAhead : this.rule.skip;\n    }\n    cmp(pos) {\n        return this.rule.cmp(pos.rule) || this.pos - pos.pos || this.skipAhead.hash - pos.skipAhead.hash ||\n            cmpSet(this.ahead, pos.ahead, (a, b) => a.cmp(b)) || cmpSet(this.ambigAhead, pos.ambigAhead, cmpStr);\n    }\n    eqSimple(pos) {\n        return pos.rule == this.rule && pos.pos == this.pos;\n    }\n    toString() {\n        let parts = this.rule.parts.map(t => t.name);\n        parts.splice(this.pos, 0, \"\");\n        return `${this.rule.name} -> ${parts.join(\" \")}`;\n    }\n    eq(other) {\n        return this == other ||\n            this.hash == other.hash && this.rule == other.rule && this.pos == other.pos && this.skipAhead == other.skipAhead &&\n                sameSet(this.ahead, other.ahead) &&\n                sameSet(this.ambigAhead, other.ambigAhead);\n    }\n    trail(maxLen = 60) {\n        let result = [];\n        for (let pos = this; pos; pos = pos.via) {\n            for (let i = pos.pos - 1; i >= 0; i--)\n                result.push(pos.rule.parts[i]);\n        }\n        let value = result.reverse().join(\" \");\n        if (value.length > maxLen)\n            value = value.slice(value.length - maxLen).replace(/.*? /, \" \");\n        return value;\n    }\n    conflicts(pos = this.pos) {\n        let result = this.rule.conflicts[pos];\n        if (pos == this.rule.parts.length && this.ambigAhead.length)\n            result = result.join(new Conflicts(0, this.ambigAhead));\n        return result;\n    }\n    static addOrigins(group, context) {\n        let result = group.slice();\n        for (let i = 0; i < result.length; i++) {\n            let next = result[i];\n            if (next.pos == 0)\n                for (let pos of context) {\n                    if (pos.next == next.rule.name && !result.includes(pos))\n                        result.push(pos);\n                }\n        }\n        return result;\n    }\n}\nfunction conflictsAt(group) {\n    let result = Conflicts.none;\n    for (let pos of group)\n        result = result.join(pos.conflicts());\n    return result;\n}\n// Applies automatic action precedence based on repeat productions.\n// These are left-associative, so reducing the `R -> R R` rule has\n// higher precedence.\nfunction compareRepeatPrec(a, b) {\n    for (let pos of a)\n        if (pos.rule.name.repeated) {\n            for (let posB of b)\n                if (posB.rule.name == pos.rule.name) {\n                    if (pos.rule.isRepeatWrap && pos.pos == 2)\n                        return 1;\n                    if (posB.rule.isRepeatWrap && posB.pos == 2)\n                        return -1;\n                }\n        }\n    return 0;\n}\nfunction cmpStr(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\nfunction termsAhead(rule, pos, after, first) {\n    let found = [];\n    for (let i = pos + 1; i < rule.parts.length; i++) {\n        let next = rule.parts[i], cont = false;\n        if (next.terminal) {\n            addTo(next, found);\n        }\n        else\n            for (let term of first[next.name]) {\n                if (term == null)\n                    cont = true;\n                else\n                    addTo(term, found);\n            }\n        if (!cont)\n            return found;\n    }\n    for (let a of after)\n        addTo(a, found);\n    return found;\n}\nfunction eqSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction sameSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i])\n            return false;\n    return true;\n}\nclass Shift {\n    constructor(term, target) {\n        this.term = term;\n        this.target = target;\n    }\n    eq(other) { return other instanceof Shift && this.term == other.term && other.target.id == this.target.id; }\n    cmp(other) { return other instanceof Reduce ? -1 : this.term.id - other.term.id || this.target.id - other.target.id; }\n    toString() { return \"s\" + this.target.id; }\n    map(mapping, states) {\n        let mapped = states[mapping[this.target.id]];\n        return mapped == this.target ? this : new Shift(this.term, mapped);\n    }\n}\nclass Reduce {\n    constructor(term, rule) {\n        this.term = term;\n        this.rule = rule;\n    }\n    eq(other) {\n        return other instanceof Reduce && this.term == other.term && other.rule.sameReduce(this.rule);\n    }\n    cmp(other) {\n        return other instanceof Shift ? 1 : this.term.id - other.term.id || this.rule.name.id - other.rule.name.id ||\n            this.rule.parts.length - other.rule.parts.length;\n    }\n    toString() { return `${this.rule.name.name}(${this.rule.parts.length})`; }\n    map() { return this; }\n}\nfunction hashPositions(set) {\n    let h = 5381;\n    for (let pos of set)\n        h = hash(h, pos.hash);\n    return h;\n}\nclass State {\n    constructor(id, set, flags = 0, skip, hash = hashPositions(set), startRule = null) {\n        this.id = id;\n        this.set = set;\n        this.flags = flags;\n        this.skip = skip;\n        this.hash = hash;\n        this.startRule = startRule;\n        this.actions = [];\n        this.actionPositions = [];\n        this.goto = [];\n        this.tokenGroup = -1;\n        this.defaultReduce = null;\n    }\n    toString() {\n        let actions = this.actions.map(t => t.term + \"=\" + t).join(\",\") +\n            (this.goto.length ? \" | \" + this.goto.map(g => g.term + \"=\" + g).join(\",\") : \"\");\n        return this.id + \": \" + this.set.filter(p => p.pos > 0).join() +\n            (this.defaultReduce ? `\\n  always ${this.defaultReduce.name}(${this.defaultReduce.parts.length})`\n                : actions.length ? \"\\n  \" + actions : \"\");\n    }\n    addActionInner(value, positions) {\n        check: for (let i = 0; i < this.actions.length; i++) {\n            let action = this.actions[i];\n            if (action.term == value.term) {\n                if (action.eq(value))\n                    return null;\n                let fullPos = Pos.addOrigins(positions, this.set), actionFullPos = Pos.addOrigins(this.actionPositions[i], this.set);\n                let conflicts = conflictsAt(fullPos), actionConflicts = conflictsAt(actionFullPos);\n                let diff = compareRepeatPrec(fullPos, actionFullPos) || conflicts.precedence - actionConflicts.precedence;\n                if (diff > 0) { // Drop the existing action\n                    this.actions.splice(i, 1);\n                    this.actionPositions.splice(i, 1);\n                    i--;\n                    continue check;\n                }\n                else if (diff < 0) { // Drop this one\n                    return null;\n                }\n                else if (conflicts.ambigGroups.some(g => actionConflicts.ambigGroups.includes(g))) { // Explicitly allowed ambiguity\n                    continue check;\n                }\n                else { // Not resolved\n                    return action;\n                }\n            }\n        }\n        this.actions.push(value);\n        this.actionPositions.push(positions);\n        return null;\n    }\n    addAction(value, positions, conflicts) {\n        let conflict = this.addActionInner(value, positions);\n        if (conflict) {\n            let conflictPos = this.actionPositions[this.actions.indexOf(conflict)][0];\n            let rules = [positions[0].rule.name, conflictPos.rule.name];\n            if (conflicts.some(c => c.rules.some(r => rules.includes(r))))\n                return;\n            let error;\n            if (conflict instanceof Shift)\n                error = `shift/reduce conflict between\\n  ${conflictPos}\\nand\\n  ${positions[0].rule}`;\n            else\n                error = `reduce/reduce conflict between\\n  ${conflictPos.rule}\\nand\\n  ${positions[0].rule}`;\n            error += `\\nWith input:\\n  ${positions[0].trail(70)}  ${value.term} `;\n            error += findConflictOrigin(conflictPos, positions[0]);\n            conflicts.push(new Conflict(error, rules));\n        }\n    }\n    getGoto(term) {\n        return this.goto.find(a => a.term == term);\n    }\n    hasSet(set) {\n        return eqSet(this.set, set);\n    }\n    finish() {\n        if (this.actions.length) {\n            let first = this.actions[0];\n            if (first instanceof Reduce) {\n                let { rule } = first;\n                if (this.actions.every(a => a instanceof Reduce && a.rule.sameReduce(rule)))\n                    this.defaultReduce = rule;\n            }\n        }\n        this.actions.sort((a, b) => a.cmp(b));\n        this.goto.sort((a, b) => a.cmp(b));\n    }\n    eq(other) {\n        let dThis = this.defaultReduce, dOther = other.defaultReduce;\n        if (dThis || dOther)\n            return dThis && dOther ? dThis.sameReduce(dOther) : false;\n        return this.skip == other.skip &&\n            this.tokenGroup == other.tokenGroup &&\n            eqSet(this.actions, other.actions) &&\n            eqSet(this.goto, other.goto);\n    }\n}\nfunction closure(set, first) {\n    let added = [], redo = [];\n    function addFor(name, ahead, ambigAhead, skipAhead, via) {\n        for (let rule of name.rules) {\n            let add = added.find(a => a.rule == rule);\n            if (!add) {\n                let existing = set.find(p => p.pos == 0 && p.rule == rule);\n                add = existing ? new Pos(rule, 0, existing.ahead.slice(), existing.ambigAhead, existing.skipAhead, existing.via)\n                    : new Pos(rule, 0, [], none$1, skipAhead, via);\n                added.push(add);\n            }\n            if (add.skipAhead != skipAhead)\n                throw new GenError(\"Inconsistent skip sets after \" + via.trail());\n            add.ambigAhead = union(add.ambigAhead, ambigAhead);\n            for (let term of ahead)\n                if (!add.ahead.includes(term)) {\n                    add.ahead.push(term);\n                    if (add.rule.parts.length && !add.rule.parts[0].terminal)\n                        addTo(add, redo);\n                }\n        }\n    }\n    for (let pos of set) {\n        let next = pos.next;\n        if (next && !next.terminal)\n            addFor(next, termsAhead(pos.rule, pos.pos, pos.ahead, first), pos.conflicts(pos.pos + 1).ambigGroups, pos.pos == pos.rule.parts.length - 1 ? pos.skipAhead : pos.rule.skip, pos);\n    }\n    while (redo.length) {\n        let add = redo.pop();\n        addFor(add.rule.parts[0], termsAhead(add.rule, 0, add.ahead, first), union(add.rule.conflicts[1].ambigGroups, add.rule.parts.length == 1 ? add.ambigAhead : none$1), add.rule.parts.length == 1 ? add.skipAhead : add.rule.skip, add);\n    }\n    let result = set.slice();\n    for (let add of added) {\n        add.ahead.sort((a, b) => a.hash - b.hash);\n        add.finish();\n        let origIndex = set.findIndex(p => p.pos == 0 && p.rule == add.rule);\n        if (origIndex > -1)\n            result[origIndex] = add;\n        else\n            result.push(add);\n    }\n    return result.sort((a, b) => a.cmp(b));\n}\nfunction addTo(value, array) {\n    if (!array.includes(value))\n        array.push(value);\n}\nfunction computeFirstSets(terms) {\n    let table = Object.create(null);\n    for (let t of terms.terms)\n        if (!t.terminal)\n            table[t.name] = [];\n    for (;;) {\n        let change = false;\n        for (let nt of terms.terms)\n            if (!nt.terminal)\n                for (let rule of nt.rules) {\n                    let set = table[nt.name];\n                    let found = false, startLen = set.length;\n                    for (let part of rule.parts) {\n                        found = true;\n                        if (part.terminal) {\n                            addTo(part, set);\n                        }\n                        else {\n                            for (let t of table[part.name]) {\n                                if (t == null)\n                                    found = false;\n                                else\n                                    addTo(t, set);\n                            }\n                        }\n                        if (found)\n                            break;\n                    }\n                    if (!found)\n                        addTo(null, set);\n                    if (set.length > startLen)\n                        change = true;\n                }\n        if (!change)\n            return table;\n    }\n}\nclass Core {\n    constructor(set, state) {\n        this.set = set;\n        this.state = state;\n    }\n}\nclass Conflict {\n    constructor(error, rules) {\n        this.error = error;\n        this.rules = rules;\n    }\n}\nfunction findConflictOrigin(a, b) {\n    if (a.eqSimple(b))\n        return \"\";\n    function via(root, start) {\n        let hist = [];\n        for (let p = start.via; !p.eqSimple(root); p = p.via)\n            hist.push(p);\n        if (!hist.length)\n            return \"\";\n        hist.unshift(start);\n        return hist.reverse().map((p, i) => \"\\n\" + \"  \".repeat(i + 1) + (p == start ? \"\" : \"via \") + p).join(\"\");\n    }\n    for (let p = a; p; p = p.via)\n        for (let p2 = b; p2; p2 = p2.via) {\n            if (p.eqSimple(p2))\n                return \"\\nShared origin: \" + p + via(p, a) + via(p, b);\n        }\n    return \"\";\n}\n// Builds a full LR(1) automaton\nfunction buildFullAutomaton(terms, startTerms, first) {\n    let states = [];\n    let cores = {};\n    let t0 = Date.now();\n    function getState(core, top) {\n        if (core.length == 0)\n            return null;\n        let coreHash = hashPositions(core), byHash = cores[coreHash];\n        let skip;\n        for (let pos of core) {\n            if (!skip)\n                skip = pos.skip;\n            else if (skip != pos.skip)\n                throw new GenError(\"Inconsistent skip sets after \" + pos.trail());\n        }\n        if (byHash)\n            for (let known of byHash)\n                if (eqSet(core, known.set)) {\n                    if (known.state.skip != skip)\n                        throw new GenError(\"Inconsistent skip sets after \" + known.set[0].trail());\n                    return known.state;\n                }\n        let set = closure(core, first);\n        let hash = hashPositions(set), found;\n        if (!top)\n            for (let state of states)\n                if (state.hash == hash && state.hasSet(set))\n                    found = state;\n        if (!found) {\n            found = new State(states.length, set, 0, skip, hash, top);\n            states.push(found);\n            if (timing && states.length % 500 == 0)\n                console.log(`${states.length} states after ${((Date.now() - t0) / 1000).toFixed(2)}s`);\n        }\n        (cores[coreHash] || (cores[coreHash] = [])).push(new Core(core, found));\n        return found;\n    }\n    for (const startTerm of startTerms) {\n        const startSkip = startTerm.rules.length ? startTerm.rules[0].skip : terms.names[\"%noskip\"];\n        getState(startTerm.rules.map(rule => new Pos(rule, 0, [terms.eof], none$1, startSkip, null).finish()), startTerm);\n    }\n    let conflicts = [];\n    for (let filled = 0; filled < states.length; filled++) {\n        let state = states[filled];\n        let byTerm = [], byTermPos = [], atEnd = [];\n        for (let pos of state.set) {\n            if (pos.pos == pos.rule.parts.length) {\n                if (!pos.rule.name.top)\n                    atEnd.push(pos);\n            }\n            else {\n                let next = pos.rule.parts[pos.pos];\n                let index = byTerm.indexOf(next);\n                if (index < 0) {\n                    byTerm.push(next);\n                    byTermPos.push([pos]);\n                }\n                else {\n                    byTermPos[index].push(pos);\n                }\n            }\n        }\n        for (let i = 0; i < byTerm.length; i++) {\n            let term = byTerm[i], positions = byTermPos[i].map(p => p.advance());\n            if (term.terminal) {\n                let set = applyCut(positions);\n                let next = getState(set);\n                if (next)\n                    state.addAction(new Shift(term, next), byTermPos[i], conflicts);\n            }\n            else {\n                let goto = getState(positions);\n                if (goto)\n                    state.goto.push(new Shift(term, goto));\n            }\n        }\n        let replaced = false;\n        for (let pos of atEnd)\n            for (let ahead of pos.ahead) {\n                let count = state.actions.length;\n                state.addAction(new Reduce(ahead, pos.rule), [pos], conflicts);\n                if (state.actions.length == count)\n                    replaced = true;\n            }\n        // If some actions were replaced by others, double-check whether\n        // goto entries are now superfluous (for example, in an operator\n        // precedence-related state that has a shift for `*` but only a\n        // reduce for `+`, we don't need a goto entry for rules that start\n        // with `+`)\n        if (replaced)\n            for (let i = 0; i < state.goto.length; i++) {\n                let start = first[state.goto[i].term.name];\n                if (!start.some(term => state.actions.some(a => a.term == term && (a instanceof Shift))))\n                    state.goto.splice(i--, 1);\n            }\n    }\n    if (conflicts.length)\n        throw new GenError(conflicts.map(c => c.error).join(\"\\n\\n\"));\n    // Resolve alwaysReduce and sort actions\n    for (let state of states)\n        state.finish();\n    if (timing)\n        console.log(`${states.length} states total.`);\n    return states;\n}\nfunction applyCut(set) {\n    let found = null, cut = 1;\n    for (let pos of set) {\n        let value = pos.rule.conflicts[pos.pos - 1].cut;\n        if (value < cut)\n            continue;\n        if (!found || value > cut) {\n            cut = value;\n            found = [];\n        }\n        found.push(pos);\n    }\n    return found || set;\n}\nfunction canMergeInner(a, b, mapping) {\n    for (let goto of a.goto)\n        for (let other of b.goto) {\n            if (goto.term == other.term && mapping[goto.target.id] != mapping[other.target.id])\n                return false;\n        }\n    actions: for (let action of a.actions) {\n        let conflict = false;\n        for (let other of b.actions)\n            if (other.term == action.term) {\n                if (action instanceof Shift\n                    ? other instanceof Shift && mapping[action.target.id] == mapping[other.target.id]\n                    : other.eq(action))\n                    continue actions;\n                conflict = true;\n            }\n        if (conflict)\n            return false;\n    }\n    return true;\n}\nfunction canMerge(a, b, mapping) {\n    return canMergeInner(a, b, mapping) && canMergeInner(b, a, mapping);\n}\nfunction mergeStates(states, mapping) {\n    let newStates = [];\n    for (let state of states) {\n        let newID = mapping[state.id];\n        if (!newStates[newID]) {\n            newStates[newID] = new State(newID, state.set, 0, state.skip, state.hash, state.startRule);\n            newStates[newID].tokenGroup = state.tokenGroup;\n            newStates[newID].defaultReduce = state.defaultReduce;\n        }\n    }\n    for (let state of states) {\n        let newID = mapping[state.id], target = newStates[newID];\n        target.flags |= state.flags;\n        for (let i = 0; i < state.actions.length; i++) {\n            let action = state.actions[i].map(mapping, newStates);\n            if (!target.actions.some(a => a.eq(action))) {\n                target.actions.push(action);\n                target.actionPositions.push(state.actionPositions[i]);\n            }\n        }\n        for (let goto of state.goto) {\n            let mapped = goto.map(mapping, newStates);\n            if (!target.goto.some(g => g.eq(mapped)))\n                target.goto.push(mapped);\n        }\n    }\n    return newStates;\n}\nclass Group {\n    constructor(origin, member) {\n        this.origin = origin;\n        this.members = [member];\n    }\n}\nfunction samePosSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].eqSimple(b[i]))\n            return false;\n    return true;\n}\n// Collapse an LR(1) automaton to an LALR-like automaton\nfunction collapseAutomaton(states) {\n    let mapping = [], groups = [];\n    assignGroups: for (let i = 0; i < states.length; i++) {\n        let state = states[i];\n        if (!state.startRule)\n            for (let j = 0; j < groups.length; j++) {\n                let group = groups[j], other = states[group.members[0]];\n                if (state.tokenGroup == other.tokenGroup &&\n                    state.skip == other.skip &&\n                    !other.startRule &&\n                    samePosSet(state.set, other.set)) {\n                    group.members.push(i);\n                    mapping.push(j);\n                    continue assignGroups;\n                }\n            }\n        mapping.push(groups.length);\n        groups.push(new Group(groups.length, i));\n    }\n    function spill(groupIndex, index) {\n        let group = groups[groupIndex], state = states[group.members[index]];\n        let pop = group.members.pop();\n        if (index != group.members.length)\n            group.members[index] = pop;\n        for (let i = groupIndex + 1; i < groups.length; i++) {\n            mapping[state.id] = i;\n            if (groups[i].origin == group.origin &&\n                groups[i].members.every(id => canMerge(state, states[id], mapping))) {\n                groups[i].members.push(state.id);\n                return;\n            }\n        }\n        mapping[state.id] = groups.length;\n        groups.push(new Group(group.origin, state.id));\n    }\n    for (let pass = 1;; pass++) {\n        let conflicts = false, t0 = Date.now();\n        for (let g = 0, startLen = groups.length; g < startLen; g++) {\n            let group = groups[g];\n            for (let i = 0; i < group.members.length - 1; i++) {\n                for (let j = i + 1; j < group.members.length; j++) {\n                    let idA = group.members[i], idB = group.members[j];\n                    if (!canMerge(states[idA], states[idB], mapping)) {\n                        conflicts = true;\n                        spill(g, j--);\n                    }\n                }\n            }\n        }\n        if (timing)\n            console.log(`Collapse pass ${pass}${conflicts ? `` : `, done`} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n        if (!conflicts)\n            return mergeStates(states, mapping);\n    }\n}\nfunction mergeIdentical(states) {\n    for (let pass = 1;; pass++) {\n        let mapping = [], didMerge = false, t0 = Date.now();\n        let newStates = [];\n        // Find states that either have the same alwaysReduce or the same\n        // actions, and merge them.\n        for (let i = 0; i < states.length; i++) {\n            let state = states[i];\n            let match = newStates.findIndex(s => state.eq(s));\n            if (match < 0) {\n                mapping[i] = newStates.length;\n                newStates.push(state);\n            }\n            else {\n                mapping[i] = match;\n                didMerge = true;\n                let other = newStates[match], add = null;\n                for (let pos of state.set)\n                    if (!other.set.some(p => p.eqSimple(pos)))\n                        (add || (add = [])).push(pos);\n                if (add)\n                    other.set = add.concat(other.set).sort((a, b) => a.cmp(b));\n            }\n        }\n        if (timing)\n            console.log(`Merge identical pass ${pass}${didMerge ? \"\" : \", done\"} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n        if (!didMerge)\n            return states;\n        // Make sure actions point at merged state objects\n        for (let state of newStates)\n            if (!state.defaultReduce) {\n                state.actions = state.actions.map(a => a.map(mapping, newStates));\n                state.goto = state.goto.map(a => a.map(mapping, newStates));\n            }\n        // Renumber ids\n        for (let i = 0; i < newStates.length; i++)\n            newStates[i].id = i;\n        states = newStates;\n    }\n}\nconst none$1 = [];\nfunction finishAutomaton(full) {\n    return mergeIdentical(collapseAutomaton(full));\n}\n\n// Encode numbers as groups of printable ascii characters\n//\n// - 0xffff, which is often used as placeholder, is encoded as \"~\"\n//\n// - The characters from \" \" (32) to \"}\" (125), excluding '\"' and\n//   \"\\\\\", indicate values from 0 to 92\n//\n// - The first bit in a 'digit' is used to indicate whether this is\n//   the end of a number.\n//\n// - That leaves 46 other values, which are actually significant.\n//\n// - The digits in a number are ordered from high to low significance.\nfunction digitToChar(digit) {\n    let ch = digit + 32 /* Encode.Start */;\n    if (ch >= 34 /* Encode.Gap1 */)\n        ch++;\n    if (ch >= 92 /* Encode.Gap2 */)\n        ch++;\n    return String.fromCharCode(ch);\n}\nfunction encode(value, max = 0xffff) {\n    if (value > max)\n        throw new Error(\"Trying to encode a number that's too big: \" + value);\n    if (value == 65535 /* Encode.BigVal */)\n        return String.fromCharCode(126 /* Encode.BigValCode */);\n    let result = \"\";\n    for (let first = 46 /* Encode.Base */;; first = 0) {\n        let low = value % 46 /* Encode.Base */, rest = value - low;\n        result = digitToChar(low + first) + result;\n        if (rest == 0)\n            break;\n        value = rest / 46 /* Encode.Base */;\n    }\n    return result;\n}\nfunction encodeArray(values, max = 0xffff) {\n    let result = '\"' + encode(values.length, 0xffffffff);\n    for (let i = 0; i < values.length; i++)\n        result += encode(values[i], max);\n    result += '\"';\n    return result;\n}\n\nconst none = [];\nclass Parts {\n    constructor(terms, conflicts) {\n        this.terms = terms;\n        this.conflicts = conflicts;\n    }\n    concat(other) {\n        if (this == Parts.none)\n            return other;\n        if (other == Parts.none)\n            return this;\n        let conflicts = null;\n        if (this.conflicts || other.conflicts) {\n            conflicts = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();\n            let otherConflicts = other.ensureConflicts();\n            conflicts[conflicts.length - 1] = conflicts[conflicts.length - 1].join(otherConflicts[0]);\n            for (let i = 1; i < otherConflicts.length; i++)\n                conflicts.push(otherConflicts[i]);\n        }\n        return new Parts(this.terms.concat(other.terms), conflicts);\n    }\n    withConflicts(pos, conflicts) {\n        if (conflicts == Conflicts.none)\n            return this;\n        let array = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();\n        array[pos] = array[pos].join(conflicts);\n        return new Parts(this.terms, array);\n    }\n    ensureConflicts() {\n        if (this.conflicts)\n            return this.conflicts;\n        let empty = [];\n        for (let i = 0; i <= this.terms.length; i++)\n            empty.push(Conflicts.none);\n        return empty;\n    }\n}\nParts.none = new Parts(none, null);\nfunction p(...terms) { return new Parts(terms, null); }\nclass BuiltRule {\n    constructor(id, args, term) {\n        this.id = id;\n        this.args = args;\n        this.term = term;\n    }\n    matches(expr) {\n        return this.id == expr.id.name && exprsEq(expr.args, this.args);\n    }\n    matchesRepeat(expr) {\n        return this.id == \"+\" && exprEq(expr.expr, this.args[0]);\n    }\n}\nclass Builder {\n    constructor(text, options) {\n        this.options = options;\n        this.terms = new TermSet;\n        this.specialized = Object.create(null);\n        this.tokenOrigins = Object.create(null);\n        this.rules = [];\n        this.built = [];\n        this.ruleNames = Object.create(null);\n        this.namespaces = Object.create(null);\n        this.namedTerms = Object.create(null);\n        this.termTable = Object.create(null);\n        this.knownProps = Object.create(null);\n        this.dynamicRulePrecedences = [];\n        this.definedGroups = [];\n        this.astRules = [];\n        this.currentSkip = [];\n        time(\"Parse\", () => {\n            this.input = new Input(text, options.fileName);\n            this.ast = this.input.parse();\n        });\n        let NP = NodeProp;\n        for (let prop in NP) {\n            if (NP[prop] instanceof NodeProp && !NP[prop].perNode)\n                this.knownProps[prop] = { prop: NP[prop], source: { name: prop, from: null } };\n        }\n        for (let prop of this.ast.externalProps) {\n            this.knownProps[prop.id.name] = {\n                prop: this.options.externalProp ? this.options.externalProp(prop.id.name) : new NodeProp(),\n                source: { name: prop.externalID.name, from: prop.source }\n            };\n        }\n        this.dialects = this.ast.dialects.map(d => d.name);\n        this.tokens = new MainTokenSet(this, this.ast.tokens);\n        this.localTokens = this.ast.localTokens.map(g => new LocalTokenSet(this, g));\n        this.externalTokens = this.ast.externalTokens.map(ext => new ExternalTokenSet(this, ext));\n        this.externalSpecializers = this.ast.externalSpecializers.map(decl => new ExternalSpecializer(this, decl));\n        time(\"Build rules\", () => {\n            let noSkip = this.newName(\"%noskip\", true);\n            this.defineRule(noSkip, []);\n            let mainSkip = this.ast.mainSkip ? this.newName(\"%mainskip\", true) : noSkip;\n            let scopedSkip = [], topRules = [];\n            for (let rule of this.ast.rules)\n                this.astRules.push({ skip: mainSkip, rule });\n            for (let rule of this.ast.topRules)\n                topRules.push({ skip: mainSkip, rule });\n            for (let scoped of this.ast.scopedSkip) {\n                let skip = noSkip, found = this.ast.scopedSkip.findIndex((sc, i) => i < scopedSkip.length && exprEq(sc.expr, scoped.expr));\n                if (found > -1)\n                    skip = scopedSkip[found];\n                else if (this.ast.mainSkip && exprEq(scoped.expr, this.ast.mainSkip))\n                    skip = mainSkip;\n                else if (!isEmpty(scoped.expr))\n                    skip = this.newName(\"%skip\", true);\n                scopedSkip.push(skip);\n                for (let rule of scoped.rules)\n                    this.astRules.push({ skip, rule });\n                for (let rule of scoped.topRules)\n                    topRules.push({ skip, rule });\n            }\n            for (let { rule } of this.astRules) {\n                this.unique(rule.id);\n            }\n            this.currentSkip.push(noSkip);\n            this.skipRules = mainSkip == noSkip ? [mainSkip] : [noSkip, mainSkip];\n            if (mainSkip != noSkip)\n                this.defineRule(mainSkip, this.normalizeExpr(this.ast.mainSkip));\n            for (let i = 0; i < this.ast.scopedSkip.length; i++) {\n                let skip = scopedSkip[i];\n                if (!this.skipRules.includes(skip)) {\n                    this.skipRules.push(skip);\n                    if (skip != noSkip)\n                        this.defineRule(skip, this.normalizeExpr(this.ast.scopedSkip[i].expr));\n                }\n            }\n            this.currentSkip.pop();\n            for (let { rule, skip } of topRules.sort((a, b) => a.rule.start - b.rule.start)) {\n                this.unique(rule.id);\n                this.used(rule.id.name);\n                this.currentSkip.push(skip);\n                let { name, props } = this.nodeInfo(rule.props, \"a\", rule.id.name, none, none, rule.expr);\n                let term = this.terms.makeTop(name, props);\n                this.namedTerms[name] = term;\n                this.defineRule(term, this.normalizeExpr(rule.expr));\n                this.currentSkip.pop();\n            }\n            for (let ext of this.externalSpecializers)\n                ext.finish();\n            for (let { skip, rule } of this.astRules) {\n                if (this.ruleNames[rule.id.name] && isExported(rule) && !rule.params.length) {\n                    this.buildRule(rule, [], skip, false);\n                    if (rule.expr instanceof SequenceExpression && rule.expr.exprs.length == 0)\n                        this.used(rule.id.name);\n                }\n            }\n        });\n        for (let name in this.ruleNames) {\n            let value = this.ruleNames[name];\n            if (value)\n                this.warn(`Unused rule '${value.name}'`, value.start);\n        }\n        this.tokens.takePrecedences();\n        this.tokens.takeConflicts();\n        for (let lt of this.localTokens)\n            lt.takePrecedences();\n        for (let { name, group, rule } of this.definedGroups)\n            this.defineGroup(name, group, rule);\n        this.checkGroups();\n    }\n    unique(id) {\n        if (id.name in this.ruleNames)\n            this.raise(`Duplicate definition of rule '${id.name}'`, id.start);\n        this.ruleNames[id.name] = id;\n    }\n    used(name) {\n        this.ruleNames[name] = null;\n    }\n    newName(base, nodeName = null, props = {}) {\n        for (let i = nodeName ? 0 : 1;; i++) {\n            let name = i ? `${base}-${i}` : base;\n            if (!this.terms.names[name])\n                return this.terms.makeNonTerminal(name, nodeName === true ? null : nodeName, props);\n        }\n    }\n    prepareParser() {\n        let rules = time(\"Simplify rules\", () => simplifyRules(this.rules, [\n            ...this.skipRules,\n            ...this.terms.tops\n        ]));\n        let { nodeTypes, names: termNames, minRepeatTerm, maxTerm } = this.terms.finish(rules);\n        for (let prop in this.namedTerms)\n            this.termTable[prop] = this.namedTerms[prop].id;\n        if (/\\bgrammar\\b/.test(verbose))\n            console.log(rules.join(\"\\n\"));\n        let startTerms = this.terms.tops.slice();\n        let first = computeFirstSets(this.terms);\n        let skipInfo = this.skipRules.map((name, id) => {\n            let skip = [], startTokens = [], rules = [];\n            for (let rule of name.rules) {\n                if (!rule.parts.length)\n                    continue;\n                let start = rule.parts[0];\n                for (let t of start.terminal ? [start] : first[start.name] || [])\n                    if (!startTokens.includes(t))\n                        startTokens.push(t);\n                if (start.terminal && rule.parts.length == 1 && !rules.some(r => r != rule && r.parts[0] == start))\n                    skip.push(start);\n                else\n                    rules.push(rule);\n            }\n            name.rules = rules;\n            if (rules.length)\n                startTerms.push(name);\n            return { skip, rule: rules.length ? name : null, startTokens, id };\n        });\n        let fullTable = time(\"Build full automaton\", () => buildFullAutomaton(this.terms, startTerms, first));\n        let localTokens = this.localTokens\n            .map((grp, i) => grp.buildLocalGroup(fullTable, skipInfo, i));\n        let { tokenGroups, tokenPrec, tokenData } = time(\"Build token groups\", () => this.tokens.buildTokenGroups(fullTable, skipInfo, localTokens.length));\n        let table = time(\"Finish automaton\", () => finishAutomaton(fullTable));\n        let skipState = findSkipStates(table, this.terms.tops);\n        if (/\\blr\\b/.test(verbose))\n            console.log(table.join(\"\\n\"));\n        let specialized = [];\n        for (let ext of this.externalSpecializers)\n            specialized.push(ext);\n        for (let name in this.specialized)\n            specialized.push({ token: this.terms.names[name], table: buildSpecializeTable(this.specialized[name]) });\n        let tokStart = (tokenizer) => {\n            if (tokenizer instanceof ExternalTokenSet)\n                return tokenizer.ast.start;\n            return this.tokens.ast ? this.tokens.ast.start : -1;\n        };\n        let tokenizers = tokenGroups\n            .concat(this.externalTokens)\n            .sort((a, b) => tokStart(a) - tokStart(b))\n            .concat(localTokens);\n        let data = new DataBuilder;\n        let skipData = skipInfo.map(info => {\n            let actions = [];\n            for (let term of info.skip)\n                actions.push(term.id, 0, 262144 /* Action.StayFlag */ >> 16);\n            if (info.rule) {\n                let state = table.find(s => s.startRule == info.rule);\n                for (let action of state.actions)\n                    actions.push(action.term.id, state.id, 131072 /* Action.GotoFlag */ >> 16);\n            }\n            actions.push(65535 /* Seq.End */, 0 /* Seq.Done */);\n            return data.storeArray(actions);\n        });\n        let states = time(\"Finish states\", () => {\n            let states = new Uint32Array(table.length * 6 /* ParseState.Size */);\n            let forceReductions = this.computeForceReductions(table, skipInfo);\n            let finishCx = new FinishStateContext(tokenizers, data, states, skipData, skipInfo, table, this);\n            for (let s of table)\n                finishCx.finish(s, skipState(s.id), forceReductions[s.id]);\n            return states;\n        });\n        let dialects = Object.create(null);\n        for (let i = 0; i < this.dialects.length; i++)\n            dialects[this.dialects[i]] = data.storeArray((this.tokens.byDialect[i] || none).map(t => t.id).concat(65535 /* Seq.End */));\n        let dynamicPrecedences = null;\n        if (this.dynamicRulePrecedences.length) {\n            dynamicPrecedences = Object.create(null);\n            for (let { rule, prec } of this.dynamicRulePrecedences)\n                dynamicPrecedences[rule.id] = prec;\n        }\n        let topRules = Object.create(null);\n        for (let term of this.terms.tops)\n            topRules[term.nodeName] = [table.find(state => state.startRule == term).id, term.id];\n        let precTable = data.storeArray(tokenPrec.concat(65535 /* Seq.End */));\n        let { nodeProps, skippedTypes } = this.gatherNodeProps(nodeTypes);\n        return {\n            states,\n            stateData: data.finish(),\n            goto: computeGotoTable(table),\n            nodeNames: nodeTypes.filter(t => t.id < minRepeatTerm).map(t => t.nodeName).join(\" \"),\n            nodeProps,\n            skippedTypes,\n            maxTerm,\n            repeatNodeCount: nodeTypes.length - minRepeatTerm,\n            tokenizers,\n            tokenData,\n            topRules,\n            dialects,\n            dynamicPrecedences,\n            specialized,\n            tokenPrec: precTable,\n            termNames\n        };\n    }\n    getParser() {\n        let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers, tokenData, topRules, dialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();\n        let specialized = rawSpecialized.map(v => {\n            if (v instanceof ExternalSpecializer) {\n                let ext = this.options.externalSpecializer(v.ast.id.name, this.termTable);\n                return {\n                    term: v.term.id,\n                    get: (value, stack) => (ext(value, stack) << 1) |\n                        (v.ast.type == \"extend\" ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */),\n                    external: ext,\n                    extend: v.ast.type == \"extend\"\n                };\n            }\n            else {\n                return { term: v.token.id, get: (value) => v.table[value] || -1 };\n            }\n        });\n        return LRParser.deserialize({\n            version: 14 /* File.Version */,\n            states,\n            stateData,\n            goto,\n            nodeNames,\n            maxTerm,\n            repeatNodeCount,\n            nodeProps: rawNodeProps.map(({ prop, terms }) => [this.knownProps[prop].prop, ...terms]),\n            propSources: !this.options.externalPropSource ? undefined\n                : this.ast.externalPropSources.map(s => this.options.externalPropSource(s.id.name)),\n            skippedNodes: skippedTypes,\n            tokenData,\n            tokenizers: tokenizers.map(tok => tok.create()),\n            context: this.ast.context ? this.options.contextTracker : undefined,\n            topRules,\n            dialects,\n            dynamicPrecedences,\n            specialized,\n            tokenPrec,\n            termNames\n        });\n    }\n    getParserFile() {\n        let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers: rawTokenizers, tokenData, topRules, dialects: rawDialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();\n        let mod = this.options.moduleStyle || \"es\";\n        let gen = \"// This file was generated by lezer-generator. You probably shouldn't edit it.\\n\", head = gen;\n        let imports = {}, imported = Object.create(null);\n        let defined = Object.create(null);\n        for (let word of KEYWORDS)\n            defined[word] = true;\n        let exportName = this.options.exportName || \"parser\";\n        defined[exportName] = true;\n        let getName = (prefix) => {\n            for (let i = 0;; i++) {\n                let id = prefix + (i ? \"_\" + i : \"\");\n                if (!defined[id])\n                    return id;\n            }\n        };\n        let importName = (name, source, prefix = name) => {\n            let spec = name + \" from \" + source;\n            if (imported[spec])\n                return imported[spec];\n            let src = JSON.stringify(source), varName = name;\n            if (name in defined) {\n                varName = getName(prefix);\n                name += `${mod == \"cjs\" ? \":\" : \" as\"} ${varName}`;\n            }\n            defined[varName] = true;\n            (imports[src] || (imports[src] = [])).push(name);\n            return imported[spec] = varName;\n        };\n        let lrParser = importName(\"LRParser\", \"@lezer/lr\");\n        let tokenizers = rawTokenizers.map(tok => tok.createSource(importName));\n        let context = this.ast.context ? importName(this.ast.context.id.name, this.ast.context.source) : null;\n        let nodeProps = rawNodeProps.map(({ prop, terms }) => {\n            let { source } = this.knownProps[prop];\n            let propID = source.from ? importName(source.name, source.from) : JSON.stringify(source.name);\n            return `[${propID}, ${terms.map(serializePropValue).join(\",\")}]`;\n        });\n        function specializationTableString(table) {\n            return \"{__proto__:null,\" + Object.keys(table).map(key => `${/\\W/.test(key) ? JSON.stringify(key) : key}:${table[key]}`)\n                .join(\", \") + \"}\";\n        }\n        let specHead = \"\";\n        let specialized = rawSpecialized.map(v => {\n            if (v instanceof ExternalSpecializer) {\n                let name = importName(v.ast.id.name, v.ast.source);\n                return `{term: ${v.term.id}, get: (value, stack) => (${name}(value, stack) << 1)${v.ast.type == \"extend\" ? ` | ${1 /* Specialize.Extend */}` : ''}, external: ${name}${v.ast.type == \"extend\" ? ', extend: true' : ''}}`;\n            }\n            else {\n                let tableName = getName(\"spec_\" + v.token.name.replace(/\\W/g, \"\"));\n                defined[tableName] = true;\n                specHead += `const ${tableName} = ${specializationTableString(v.table)}\\n`;\n                return `{term: ${v.token.id}, get: value => ${tableName}[value] || -1}`;\n            }\n        });\n        let propSources = this.ast.externalPropSources.map(s => importName(s.id.name, s.source));\n        for (let source in imports) {\n            if (mod == \"cjs\")\n                head += `const {${imports[source].join(\", \")}} = require(${source})\\n`;\n            else\n                head += `import {${imports[source].join(\", \")}} from ${source}\\n`;\n        }\n        head += specHead;\n        function serializePropValue(value) {\n            return typeof value != \"string\" || /^(true|false|\\d+(\\.\\d+)?|\\.\\d+)$/.test(value) ? value : JSON.stringify(value);\n        }\n        let dialects = Object.keys(rawDialects).map(d => `${d}: ${rawDialects[d]}`);\n        let parserStr = `${lrParser}.deserialize({\n  version: ${14 /* File.Version */},\n  states: ${encodeArray(states, 0xffffffff)},\n  stateData: ${encodeArray(stateData)},\n  goto: ${encodeArray(goto)},\n  nodeNames: ${JSON.stringify(nodeNames)},\n  maxTerm: ${maxTerm}${context ? `,\n  context: ${context}` : \"\"}${nodeProps.length ? `,\n  nodeProps: [\n    ${nodeProps.join(\",\\n    \")}\n  ]` : \"\"}${propSources.length ? `,\n  propSources: [${propSources.join()}]` : \"\"}${skippedTypes.length ? `,\n  skippedNodes: ${JSON.stringify(skippedTypes)}` : \"\"},\n  repeatNodeCount: ${repeatNodeCount},\n  tokenData: ${encodeArray(tokenData)},\n  tokenizers: [${tokenizers.join(\", \")}],\n  topRules: ${JSON.stringify(topRules)}${dialects.length ? `,\n  dialects: {${dialects.join(\", \")}}` : \"\"}${dynamicPrecedences ? `,\n  dynamicPrecedences: ${JSON.stringify(dynamicPrecedences)}` : \"\"}${specialized.length ? `,\n  specialized: [${specialized.join(\",\")}]` : \"\"},\n  tokenPrec: ${tokenPrec}${this.options.includeNames ? `,\n  termNames: ${JSON.stringify(termNames)}` : ''}\n})`;\n        let terms = [];\n        for (let name in this.termTable) {\n            let id = name;\n            if (KEYWORDS.includes(id))\n                for (let i = 1;; i++) {\n                    id = \"_\".repeat(i) + name;\n                    if (!(id in this.termTable))\n                        break;\n                }\n            terms.push(`${id}${mod == \"cjs\" ? \":\" : \" =\"} ${this.termTable[name]}`);\n        }\n        for (let id = 0; id < this.dialects.length; id++)\n            terms.push(`Dialect_${this.dialects[id]}${mod == \"cjs\" ? \":\" : \" =\"} ${id}`);\n        return {\n            parser: head + (mod == \"cjs\" ? `exports.${exportName} = ${parserStr}\\n` : `export const ${exportName} = ${parserStr}\\n`),\n            terms: mod == \"cjs\" ? `${gen}module.exports = {\\n  ${terms.join(\",\\n  \")}\\n}`\n                : `${gen}export const\\n  ${terms.join(\",\\n  \")}\\n`\n        };\n    }\n    gatherNonSkippedNodes() {\n        let seen = Object.create(null);\n        let work = [];\n        let add = (term) => {\n            if (!seen[term.id]) {\n                seen[term.id] = true;\n                work.push(term);\n            }\n        };\n        this.terms.tops.forEach(add);\n        for (let i = 0; i < work.length; i++) {\n            for (let rule of work[i].rules)\n                for (let part of rule.parts)\n                    add(part);\n        }\n        return seen;\n    }\n    gatherNodeProps(nodeTypes) {\n        let notSkipped = this.gatherNonSkippedNodes(), skippedTypes = [];\n        let nodeProps = [];\n        for (let type of nodeTypes) {\n            if (!notSkipped[type.id] && !type.error)\n                skippedTypes.push(type.id);\n            for (let prop in type.props) {\n                let known = this.knownProps[prop];\n                if (!known)\n                    throw new GenError(\"No known prop type for \" + prop);\n                if (known.source.from == null && (known.source.name == \"repeated\" || known.source.name == \"error\"))\n                    continue;\n                let rec = nodeProps.find(r => r.prop == prop);\n                if (!rec)\n                    nodeProps.push(rec = { prop, values: {} });\n                (rec.values[type.props[prop]] || (rec.values[type.props[prop]] = [])).push(type.id);\n            }\n        }\n        return {\n            nodeProps: nodeProps.map(({ prop, values }) => {\n                let terms = [];\n                for (let val in values) {\n                    let ids = values[val];\n                    if (ids.length == 1) {\n                        terms.push(ids[0], val);\n                    }\n                    else {\n                        terms.push(-ids.length);\n                        for (let id of ids)\n                            terms.push(id);\n                        terms.push(val);\n                    }\n                }\n                return { prop, terms };\n            }),\n            skippedTypes\n        };\n    }\n    makeTerminal(name, tag, props) {\n        return this.terms.makeTerminal(this.terms.uniqueName(name), tag, props);\n    }\n    computeForceReductions(states, skipInfo) {\n        // This finds a forced reduction for every state, trying to guard\n        // against cyclic forced reductions, where a given parse stack can\n        // endlessly continue running forced reductions without making any\n        // progress.\n        //\n        // This occurs with length-1 reductions. We never generate\n        // length-0 reductions, and length-2+ reductions always shrink the\n        // stack, so they are guaranteed to make progress.\n        //\n        // If there are states S1 and S2 whose forced reductions reduce\n        // terms T1 and T2 respectively, both with a length of 1, _and_\n        // there is a state S3, which has goto entries T1 -> S2, T2 -> S1,\n        // you can get cyclic reductions. Of course, the cycle may also\n        // contain more than two steps.\n        let reductions = [];\n        let candidates = [];\n        // A map from terms to states that they are mapped to in goto\n        // entries.\n        let gotoEdges = Object.create(null);\n        for (let state of states) {\n            reductions.push(0);\n            for (let edge of state.goto) {\n                let array = gotoEdges[edge.term.id] || (gotoEdges[edge.term.id] = []);\n                let found = array.find(o => o.target == edge.target.id);\n                if (found)\n                    found.parents.push(state.id);\n                else\n                    array.push({ parents: [state.id], target: edge.target.id });\n            }\n            candidates[state.id] = state.set.filter(pos => pos.pos > 0 && !pos.rule.name.top)\n                .sort((a, b) => b.pos - a.pos || a.rule.parts.length - b.rule.parts.length);\n        }\n        // Mapping from state ids to terms that that state has a length-1\n        // forced reduction for.\n        let length1Reductions = Object.create(null);\n        function createsCycle(term, startState, parents = null) {\n            let edges = gotoEdges[term];\n            if (!edges)\n                return false;\n            return edges.some(val => {\n                let parentIntersection = parents ? parents.filter(id => val.parents.includes(id)) : val.parents;\n                if (parentIntersection.length == 0)\n                    return false;\n                if (val.target == startState)\n                    return true;\n                let found = length1Reductions[val.target];\n                return found != null && createsCycle(found, startState, parentIntersection);\n            });\n        }\n        for (let state of states) {\n            if (state.defaultReduce && state.defaultReduce.parts.length > 0) {\n                reductions[state.id] = reduceAction(state.defaultReduce, skipInfo);\n                if (state.defaultReduce.parts.length == 1)\n                    length1Reductions[state.id] = state.defaultReduce.name.id;\n            }\n        }\n        // To avoid painting states that only have one potential forced\n        // reduction into a corner, reduction assignment is done by\n        // candidate size, starting with the states with fewer candidates.\n        for (let setSize = 1;; setSize++) {\n            let done = true;\n            for (let state of states) {\n                if (state.defaultReduce)\n                    continue;\n                let set = candidates[state.id];\n                if (set.length != setSize) {\n                    if (set.length > setSize)\n                        done = false;\n                    continue;\n                }\n                for (let pos of set) {\n                    if (pos.pos != 1 || !createsCycle(pos.rule.name.id, state.id)) {\n                        reductions[state.id] = reduceAction(pos.rule, skipInfo, pos.pos);\n                        if (pos.pos == 1)\n                            length1Reductions[state.id] = pos.rule.name.id;\n                        break;\n                    }\n                }\n            }\n            if (done)\n                break;\n        }\n        return reductions;\n    }\n    substituteArgs(expr, args, params) {\n        if (args.length == 0)\n            return expr;\n        return expr.walk(expr => {\n            let found;\n            if (expr instanceof NameExpression &&\n                (found = params.findIndex(p => p.name == expr.id.name)) > -1) {\n                let arg = args[found];\n                if (expr.args.length) {\n                    if (arg instanceof NameExpression && !arg.args.length)\n                        return new NameExpression(expr.start, arg.id, expr.args);\n                    this.raise(`Passing arguments to a parameter that already has arguments`, expr.start);\n                }\n                return arg;\n            }\n            else if (expr instanceof InlineRuleExpression) {\n                let r = expr.rule, props = this.substituteArgsInProps(r.props, args, params);\n                return props == r.props ? expr :\n                    new InlineRuleExpression(expr.start, new RuleDeclaration(r.start, r.id, props, r.params, r.expr));\n            }\n            else if (expr instanceof SpecializeExpression) {\n                let props = this.substituteArgsInProps(expr.props, args, params);\n                return props == expr.props ? expr :\n                    new SpecializeExpression(expr.start, expr.type, props, expr.token, expr.content);\n            }\n            return expr;\n        });\n    }\n    substituteArgsInProps(props, args, params) {\n        let substituteInValue = (value) => {\n            let result = value;\n            for (let i = 0; i < value.length; i++) {\n                let part = value[i];\n                if (!part.name)\n                    continue;\n                let found = params.findIndex(p => p.name == part.name);\n                if (found < 0)\n                    continue;\n                if (result == value)\n                    result = value.slice();\n                let expr = args[found];\n                if (expr instanceof NameExpression && !expr.args.length)\n                    result[i] = new PropPart(part.start, expr.id.name, null);\n                else if (expr instanceof LiteralExpression)\n                    result[i] = new PropPart(part.start, expr.value, null);\n                else\n                    this.raise(`Trying to interpolate expression '${expr}' into a prop`, part.start);\n            }\n            return result;\n        };\n        let result = props;\n        for (let i = 0; i < props.length; i++) {\n            let prop = props[i], value = substituteInValue(prop.value);\n            if (value != prop.value) {\n                if (result == props)\n                    result = props.slice();\n                result[i] = new Prop(prop.start, prop.at, prop.name, value);\n            }\n        }\n        return result;\n    }\n    conflictsFor(markers) {\n        let here = Conflicts.none, atEnd = Conflicts.none;\n        for (let marker of markers) {\n            if (marker.type == \"ambig\") {\n                here = here.join(new Conflicts(0, [marker.id.name]));\n            }\n            else {\n                let precs = this.ast.precedences;\n                let index = precs ? precs.items.findIndex(item => item.id.name == marker.id.name) : -1;\n                if (index < 0)\n                    this.raise(`Reference to unknown precedence: '${marker.id.name}'`, marker.id.start);\n                let prec = precs.items[index], value = precs.items.length - index;\n                if (prec.type == \"cut\") {\n                    here = here.join(new Conflicts(0, none, value));\n                }\n                else {\n                    here = here.join(new Conflicts(value << 2));\n                    atEnd = atEnd.join(new Conflicts((value << 2) + (prec.type == \"left\" ? 1 : prec.type == \"right\" ? -1 : 0)));\n                }\n            }\n        }\n        return { here, atEnd };\n    }\n    raise(message, pos = 1) {\n        return this.input.raise(message, pos);\n    }\n    warn(message, pos = -1) {\n        let msg = this.input.message(message, pos);\n        if (this.options.warn)\n            this.options.warn(msg);\n        else\n            console.warn(msg);\n    }\n    defineRule(name, choices) {\n        let skip = this.currentSkip[this.currentSkip.length - 1];\n        for (let choice of choices)\n            this.rules.push(new Rule(name, choice.terms, choice.ensureConflicts(), skip));\n    }\n    resolve(expr) {\n        for (let built of this.built)\n            if (built.matches(expr))\n                return [p(built.term)];\n        let found = this.tokens.getToken(expr);\n        if (found)\n            return [p(found)];\n        for (let grp of this.localTokens) {\n            let found = grp.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        for (let ext of this.externalTokens) {\n            let found = ext.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        for (let ext of this.externalSpecializers) {\n            let found = ext.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        let known = this.astRules.find(r => r.rule.id.name == expr.id.name);\n        if (!known)\n            return this.raise(`Reference to undefined rule '${expr.id.name}'`, expr.start);\n        if (known.rule.params.length != expr.args.length)\n            this.raise(`Wrong number or arguments for '${expr.id.name}'`, expr.start);\n        this.used(known.rule.id.name);\n        return [p(this.buildRule(known.rule, expr.args, known.skip))];\n    }\n    // For tree-balancing reasons, repeat expressions X+ have to be\n    // normalized to something like\n    //\n    //     R -> X | R R\n    //\n    // Returns the `R` term.\n    normalizeRepeat(expr) {\n        let known = this.built.find(b => b.matchesRepeat(expr));\n        if (known)\n            return p(known.term);\n        let name = expr.expr.prec < expr.prec ? `(${expr.expr})+` : `${expr.expr}+`;\n        let term = this.terms.makeRepeat(this.terms.uniqueName(name));\n        this.built.push(new BuiltRule(\"+\", [expr.expr], term));\n        this.defineRule(term, this.normalizeExpr(expr.expr).concat(p(term, term)));\n        return p(term);\n    }\n    normalizeSequence(expr) {\n        let result = expr.exprs.map(e => this.normalizeExpr(e));\n        let builder = this;\n        function complete(start, from, endConflicts) {\n            let { here, atEnd } = builder.conflictsFor(expr.markers[from]);\n            if (from == result.length)\n                return [start.withConflicts(start.terms.length, here.join(endConflicts))];\n            let choices = [];\n            for (let choice of result[from]) {\n                for (let full of complete(start.concat(choice).withConflicts(start.terms.length, here), from + 1, endConflicts.join(atEnd)))\n                    choices.push(full);\n            }\n            return choices;\n        }\n        return complete(Parts.none, 0, Conflicts.none);\n    }\n    normalizeExpr(expr) {\n        if (expr instanceof RepeatExpression && expr.kind == \"?\") {\n            return [Parts.none, ...this.normalizeExpr(expr.expr)];\n        }\n        else if (expr instanceof RepeatExpression) {\n            let repeated = this.normalizeRepeat(expr);\n            return expr.kind == \"+\" ? [repeated] : [Parts.none, repeated];\n        }\n        else if (expr instanceof ChoiceExpression) {\n            return expr.exprs.reduce((o, e) => o.concat(this.normalizeExpr(e)), []);\n        }\n        else if (expr instanceof SequenceExpression) {\n            return this.normalizeSequence(expr);\n        }\n        else if (expr instanceof LiteralExpression) {\n            return [p(this.tokens.getLiteral(expr))];\n        }\n        else if (expr instanceof NameExpression) {\n            return this.resolve(expr);\n        }\n        else if (expr instanceof SpecializeExpression) {\n            return [p(this.resolveSpecialization(expr))];\n        }\n        else if (expr instanceof InlineRuleExpression) {\n            return [p(this.buildRule(expr.rule, none, this.currentSkip[this.currentSkip.length - 1], true))];\n        }\n        else {\n            return this.raise(`This type of expression ('${expr}') may not occur in non-token rules`, expr.start);\n        }\n    }\n    buildRule(rule, args, skip, inline = false) {\n        let expr = this.substituteArgs(rule.expr, args, rule.params);\n        let { name: nodeName, props, dynamicPrec, inline: explicitInline, group, exported } = this.nodeInfo(rule.props || none, inline ? \"pg\" : \"pgi\", rule.id.name, args, rule.params, rule.expr);\n        if (exported && rule.params.length)\n            this.warn(`Can't export parameterized rules`, rule.start);\n        if (exported && inline)\n            this.warn(`Can't export inline rule`, rule.start);\n        let name = this.newName(rule.id.name + (args.length ? \"<\" + args.join(\",\") + \">\" : \"\"), nodeName || true, props);\n        if (explicitInline)\n            name.inline = true;\n        if (dynamicPrec)\n            this.registerDynamicPrec(name, dynamicPrec);\n        if ((name.nodeType || exported) && rule.params.length == 0) {\n            if (!nodeName)\n                name.preserve = true;\n            if (!inline)\n                this.namedTerms[exported || rule.id.name] = name;\n        }\n        if (!inline)\n            this.built.push(new BuiltRule(rule.id.name, args, name));\n        this.currentSkip.push(skip);\n        this.defineRule(name, this.normalizeExpr(expr));\n        this.currentSkip.pop();\n        if (group)\n            this.definedGroups.push({ name, group, rule });\n        return name;\n    }\n    nodeInfo(props, \n    // p for dynamic precedence, d for dialect, i for inline, g for group, a for disabling the ignore test for default name\n    allow, defaultName = null, args = none, params = none, expr, defaultProps) {\n        let result = {};\n        let name = defaultName && (allow.indexOf(\"a\") > -1 || !ignored(defaultName)) && !/ /.test(defaultName) ? defaultName : null;\n        let dialect = null, dynamicPrec = 0, inline = false, group = null, exported = null;\n        for (let prop of props) {\n            if (!prop.at) {\n                if (!this.knownProps[prop.name]) {\n                    let builtin = [\"name\", \"dialect\", \"dynamicPrecedence\", \"export\", \"isGroup\"].includes(prop.name)\n                        ? ` (did you mean '@${prop.name}'?)` : \"\";\n                    this.raise(`Unknown prop name '${prop.name}'${builtin}`, prop.start);\n                }\n                result[prop.name] = this.finishProp(prop, args, params);\n            }\n            else if (prop.name == \"name\") {\n                name = this.finishProp(prop, args, params);\n                if (/ /.test(name))\n                    this.raise(`Node names cannot have spaces ('${name}')`, prop.start);\n            }\n            else if (prop.name == \"dialect\") {\n                if (allow.indexOf(\"d\") < 0)\n                    this.raise(\"Can't specify a dialect on non-token rules\", props[0].start);\n                if (prop.value.length != 1 && !prop.value[0].value)\n                    this.raise(\"The '@dialect' rule prop must hold a plain string value\");\n                let dialectID = this.dialects.indexOf(prop.value[0].value);\n                if (dialectID < 0)\n                    this.raise(`Unknown dialect '${prop.value[0].value}'`, prop.value[0].start);\n                dialect = dialectID;\n            }\n            else if (prop.name == \"dynamicPrecedence\") {\n                if (allow.indexOf(\"p\") < 0)\n                    this.raise(\"Dynamic precedence can only be specified on nonterminals\");\n                if (prop.value.length != 1 || !/^-?(?:10|\\d)$/.test(prop.value[0].value))\n                    this.raise(\"The '@dynamicPrecedence' rule prop must hold an integer between -10 and 10\");\n                dynamicPrec = +prop.value[0].value;\n            }\n            else if (prop.name == \"inline\") {\n                if (prop.value.length)\n                    this.raise(\"'@inline' doesn't take a value\", prop.value[0].start);\n                if (allow.indexOf(\"i\") < 0)\n                    this.raise(\"Inline can only be specified on nonterminals\");\n                inline = true;\n            }\n            else if (prop.name == \"isGroup\") {\n                if (allow.indexOf(\"g\") < 0)\n                    this.raise(\"'@isGroup' can only be specified on nonterminals\");\n                group = prop.value.length ? this.finishProp(prop, args, params) : defaultName;\n            }\n            else if (prop.name == \"export\") {\n                if (prop.value.length)\n                    exported = this.finishProp(prop, args, params);\n                else\n                    exported = defaultName;\n            }\n            else {\n                this.raise(`Unknown built-in prop name '@${prop.name}'`, prop.start);\n            }\n        }\n        if (expr && this.ast.autoDelim && (name || hasProps(result))) {\n            let delim = this.findDelimiters(expr);\n            if (delim) {\n                addToProp(delim[0], \"closedBy\", delim[1].nodeName);\n                addToProp(delim[1], \"openedBy\", delim[0].nodeName);\n            }\n        }\n        if (defaultProps && hasProps(defaultProps)) {\n            for (let prop in defaultProps)\n                if (!(prop in result))\n                    result[prop] = defaultProps[prop];\n        }\n        if (hasProps(result) && !name)\n            this.raise(`Node has properties but no name`, props.length ? props[0].start : expr.start);\n        if (inline && (hasProps(result) || dialect || dynamicPrec))\n            this.raise(`Inline nodes can't have props, dynamic precedence, or a dialect`, props[0].start);\n        if (inline && name)\n            name = null;\n        return { name, props: result, dialect, dynamicPrec, inline, group, exported };\n    }\n    finishProp(prop, args, params) {\n        return prop.value.map(part => {\n            if (part.value)\n                return part.value;\n            let pos = params.findIndex(param => param.name == part.name);\n            if (pos < 0)\n                this.raise(`Property refers to '${part.name}', but no parameter by that name is in scope`, part.start);\n            let expr = args[pos];\n            if (expr instanceof NameExpression && !expr.args.length)\n                return expr.id.name;\n            if (expr instanceof LiteralExpression)\n                return expr.value;\n            return this.raise(`Expression '${expr}' can not be used as part of a property value`, part.start);\n        }).join(\"\");\n    }\n    resolveSpecialization(expr) {\n        let type = expr.type;\n        let { name, props, dialect } = this.nodeInfo(expr.props, \"d\");\n        let terminal = this.normalizeExpr(expr.token);\n        if (terminal.length != 1 || terminal[0].terms.length != 1 || !terminal[0].terms[0].terminal)\n            this.raise(`The first argument to '${type}' must resolve to a token`, expr.token.start);\n        let values;\n        if (expr.content instanceof LiteralExpression)\n            values = [expr.content.value];\n        else if ((expr.content instanceof ChoiceExpression) && expr.content.exprs.every(e => e instanceof LiteralExpression))\n            values = expr.content.exprs.map(expr => expr.value);\n        else\n            return this.raise(`The second argument to '${expr.type}' must be a literal or choice of literals`, expr.content.start);\n        let term = terminal[0].terms[0], token = null;\n        let table = this.specialized[term.name] || (this.specialized[term.name] = []);\n        for (let value of values) {\n            let known = table.find(sp => sp.value == value);\n            if (known == null) {\n                if (!token) {\n                    token = this.makeTerminal(term.name + \"/\" + JSON.stringify(value), name, props);\n                    if (dialect != null)\n                        (this.tokens.byDialect[dialect] || (this.tokens.byDialect[dialect] = [])).push(token);\n                }\n                table.push({ value, term: token, type, dialect, name });\n                this.tokenOrigins[token.name] = { spec: term };\n            }\n            else {\n                if (known.type != type)\n                    this.raise(`Conflicting specialization types for ${JSON.stringify(value)} of ${term.name} (${type} vs ${known.type})`, expr.start);\n                if (known.dialect != dialect)\n                    this.raise(`Conflicting dialects for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                if (known.name != name)\n                    this.raise(`Conflicting names for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                if (token && known.term != token)\n                    this.raise(`Conflicting specialization tokens for ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                token = known.term;\n            }\n        }\n        return token;\n    }\n    findDelimiters(expr) {\n        if (!(expr instanceof SequenceExpression) || expr.exprs.length < 2)\n            return null;\n        let findToken = (expr) => {\n            if (expr instanceof LiteralExpression)\n                return { term: this.tokens.getLiteral(expr), str: expr.value };\n            if (expr instanceof NameExpression && expr.args.length == 0) {\n                let rule = this.ast.rules.find(r => r.id.name == expr.id.name);\n                if (rule)\n                    return findToken(rule.expr);\n                let token = this.tokens.rules.find(r => r.id.name == expr.id.name);\n                if (token && token.expr instanceof LiteralExpression)\n                    return { term: this.tokens.getToken(expr), str: token.expr.value };\n            }\n            return null;\n        };\n        let lastToken = findToken(expr.exprs[expr.exprs.length - 1]);\n        if (!lastToken || !lastToken.term.nodeName)\n            return null;\n        const brackets = [\"()\", \"[]\", \"{}\", \"<>\"];\n        let bracket = brackets.find(b => lastToken.str.indexOf(b[1]) > -1 && lastToken.str.indexOf(b[0]) < 0);\n        if (!bracket)\n            return null;\n        let firstToken = findToken(expr.exprs[0]);\n        if (!firstToken || !firstToken.term.nodeName ||\n            firstToken.str.indexOf(bracket[0]) < 0 || firstToken.str.indexOf(bracket[1]) > -1)\n            return null;\n        return [firstToken.term, lastToken.term];\n    }\n    registerDynamicPrec(term, prec) {\n        this.dynamicRulePrecedences.push({ rule: term, prec });\n        term.preserve = true;\n    }\n    defineGroup(rule, group, ast) {\n        var _a;\n        let recur = [];\n        let getNamed = (rule) => {\n            if (rule.nodeName)\n                return [rule];\n            if (recur.includes(rule))\n                this.raise(`Rule '${ast.id.name}' cannot define a group because it contains a non-named recursive rule ('${rule.name}')`, ast.start);\n            let result = [];\n            recur.push(rule);\n            for (let r of this.rules)\n                if (r.name == rule) {\n                    let names = r.parts.map(getNamed).filter(x => x.length);\n                    if (names.length > 1)\n                        this.raise(`Rule '${ast.id.name}' cannot define a group because some choices produce multiple named nodes`, ast.start);\n                    if (names.length == 1)\n                        for (let n of names[0])\n                            result.push(n);\n                }\n            recur.pop();\n            return result;\n        };\n        for (let name of getNamed(rule))\n            name.props[\"group\"] = (((_a = name.props[\"group\"]) === null || _a === void 0 ? void 0 : _a.split(\" \")) || []).concat(group).sort().join(\" \");\n    }\n    checkGroups() {\n        let groups = Object.create(null), nodeNames = Object.create(null);\n        for (let term of this.terms.terms)\n            if (term.nodeName) {\n                nodeNames[term.nodeName] = true;\n                if (term.props[\"group\"])\n                    for (let group of term.props[\"group\"].split(\" \")) {\n                        (groups[group] || (groups[group] = [])).push(term);\n                    }\n            }\n        let names = Object.keys(groups);\n        for (let i = 0; i < names.length; i++) {\n            let name = names[i], terms = groups[name];\n            if (nodeNames[name])\n                this.warn(`Group name '${name}' conflicts with a node of the same name`);\n            for (let j = i + 1; j < names.length; j++) {\n                let other = groups[names[j]];\n                if (terms.some(t => other.includes(t)) &&\n                    (terms.length > other.length ? other.some(t => !terms.includes(t)) : terms.some(t => !other.includes(t))))\n                    this.warn(`Groups '${name}' and '${names[j]}' overlap without one being a superset of the other`);\n            }\n        }\n    }\n}\nconst MinSharedActions = 5;\nclass FinishStateContext {\n    constructor(tokenizers, data, stateArray, skipData, skipInfo, states, builder) {\n        this.tokenizers = tokenizers;\n        this.data = data;\n        this.stateArray = stateArray;\n        this.skipData = skipData;\n        this.skipInfo = skipInfo;\n        this.states = states;\n        this.builder = builder;\n        this.sharedActions = [];\n    }\n    findSharedActions(state) {\n        if (state.actions.length < MinSharedActions)\n            return null;\n        let found = null;\n        for (let shared of this.sharedActions) {\n            if ((!found || shared.actions.length > found.actions.length) &&\n                shared.actions.every(a => state.actions.some(b => b.eq(a))))\n                found = shared;\n        }\n        if (found)\n            return found;\n        let max = null, scratch = [];\n        for (let i = state.id + 1; i < this.states.length; i++) {\n            let other = this.states[i], fill = 0;\n            if (other.defaultReduce || other.actions.length < MinSharedActions)\n                continue;\n            for (let a of state.actions)\n                for (let b of other.actions)\n                    if (a.eq(b))\n                        scratch[fill++] = a;\n            if (fill >= MinSharedActions && (!max || max.length < fill)) {\n                max = scratch;\n                scratch = [];\n            }\n        }\n        if (!max)\n            return null;\n        let result = { actions: max, addr: this.storeActions(max, -1, null) };\n        this.sharedActions.push(result);\n        return result;\n    }\n    storeActions(actions, skipReduce, shared) {\n        if (skipReduce < 0 && shared && shared.actions.length == actions.length)\n            return shared.addr;\n        let data = [];\n        for (let action of actions) {\n            if (shared && shared.actions.some(a => a.eq(action)))\n                continue;\n            if (action instanceof Shift) {\n                data.push(action.term.id, action.target.id, 0);\n            }\n            else {\n                let code = reduceAction(action.rule, this.skipInfo);\n                if (code != skipReduce)\n                    data.push(action.term.id, code & 65535 /* Action.ValueMask */, code >> 16);\n            }\n        }\n        data.push(65535 /* Seq.End */);\n        if (skipReduce > -1)\n            data.push(2 /* Seq.Other */, skipReduce & 65535 /* Action.ValueMask */, skipReduce >> 16);\n        else if (shared)\n            data.push(1 /* Seq.Next */, shared.addr & 0xffff, shared.addr >> 16);\n        else\n            data.push(0 /* Seq.Done */);\n        return this.data.storeArray(data);\n    }\n    finish(state, isSkip, forcedReduce) {\n        let b = this.builder;\n        let skipID = b.skipRules.indexOf(state.skip);\n        let skipTable = this.skipData[skipID], skipTerms = this.skipInfo[skipID].startTokens;\n        let defaultReduce = state.defaultReduce ? reduceAction(state.defaultReduce, this.skipInfo) : 0;\n        let flags = isSkip ? 1 /* StateFlag.Skipped */ : 0;\n        let skipReduce = -1, shared = null;\n        if (defaultReduce == 0) {\n            if (isSkip)\n                for (const action of state.actions)\n                    if (action instanceof Reduce && action.term.eof)\n                        skipReduce = reduceAction(action.rule, this.skipInfo);\n            if (skipReduce < 0)\n                shared = this.findSharedActions(state);\n        }\n        if (state.set.some(p => p.rule.name.top && p.pos == p.rule.parts.length))\n            flags |= 2 /* StateFlag.Accepting */;\n        let external = [];\n        for (let i = 0; i < state.actions.length + skipTerms.length; i++) {\n            let term = i < state.actions.length ? state.actions[i].term : skipTerms[i - state.actions.length];\n            for (;;) {\n                let orig = b.tokenOrigins[term.name];\n                if (orig && orig.spec) {\n                    term = orig.spec;\n                    continue;\n                }\n                if (orig && (orig.external instanceof ExternalTokenSet))\n                    addToSet(external, orig.external);\n                break;\n            }\n        }\n        let tokenizerMask = 0;\n        for (let i = 0; i < this.tokenizers.length; i++) {\n            let tok = this.tokenizers[i];\n            if (external.includes(tok) || tok.groupID == state.tokenGroup)\n                tokenizerMask |= (1 << i);\n        }\n        let base = state.id * 6 /* ParseState.Size */;\n        this.stateArray[base + 0 /* ParseState.Flags */] = flags;\n        this.stateArray[base + 1 /* ParseState.Actions */] = this.storeActions(defaultReduce ? none : state.actions, skipReduce, shared);\n        this.stateArray[base + 2 /* ParseState.Skip */] = skipTable;\n        this.stateArray[base + 3 /* ParseState.TokenizerMask */] = tokenizerMask;\n        this.stateArray[base + 4 /* ParseState.DefaultReduce */] = defaultReduce;\n        this.stateArray[base + 5 /* ParseState.ForcedReduce */] = forcedReduce;\n    }\n}\nfunction addToProp(term, prop, value) {\n    let cur = term.props[prop];\n    if (!cur || cur.split(\" \").indexOf(value) < 0)\n        term.props[prop] = cur ? cur + \" \" + value : value;\n}\nfunction buildSpecializeTable(spec) {\n    let table = Object.create(null);\n    for (let { value, term, type } of spec) {\n        let code = type == \"specialize\" ? 0 /* Specialize.Specialize */ : 1 /* Specialize.Extend */;\n        table[value] = (term.id << 1) | code;\n    }\n    return table;\n}\nfunction reduceAction(rule, skipInfo, depth = rule.parts.length) {\n    return rule.name.id | 65536 /* Action.ReduceFlag */ |\n        (rule.isRepeatWrap && depth == rule.parts.length ? 131072 /* Action.RepeatFlag */ : 0) |\n        (skipInfo.some(i => i.rule == rule.name) ? 262144 /* Action.StayFlag */ : 0) |\n        (depth << 19 /* Action.ReduceDepthShift */);\n}\nfunction findArray(data, value) {\n    search: for (let i = 0;;) {\n        let next = data.indexOf(value[0], i);\n        if (next == -1 || next + value.length > data.length)\n            break;\n        for (let j = 1; j < value.length; j++) {\n            if (value[j] != data[next + j]) {\n                i = next + 1;\n                continue search;\n            }\n        }\n        return next;\n    }\n    return -1;\n}\nfunction findSkipStates(table, startRules) {\n    let nonSkip = Object.create(null);\n    let work = [];\n    let add = (state) => {\n        if (!nonSkip[state.id]) {\n            nonSkip[state.id] = true;\n            work.push(state);\n        }\n    };\n    for (let state of table)\n        if (state.startRule && startRules.includes(state.startRule))\n            add(state);\n    for (let i = 0; i < work.length; i++) {\n        for (let a of work[i].actions)\n            if (a instanceof Shift)\n                add(a.target);\n        for (let a of work[i].goto)\n            add(a.target);\n    }\n    return (id) => !nonSkip[id];\n}\nclass DataBuilder {\n    constructor() {\n        this.data = [];\n    }\n    storeArray(data) {\n        let found = findArray(this.data, data);\n        if (found > -1)\n            return found;\n        let pos = this.data.length;\n        for (let num of data)\n            this.data.push(num);\n        return pos;\n    }\n    finish() {\n        return Uint16Array.from(this.data);\n    }\n}\n// The goto table maps a start state + a term to a new state, and is\n// used to determine the new state when reducing. Because this allows\n// more more efficient representation and access, unlike the action\n// tables, the goto table is organized by term, with groups of start\n// states that map to a given end state enumerated for each term.\n// Since many terms only have a single valid goto target, this makes\n// it cheaper to look those up.\n//\n// (Unfortunately, though the standard LR parsing mechanism never\n// looks up invalid goto states, the incremental parsing mechanism\n// needs accurate goto information for a state/term pair, so we do\n// need to store state ids even for terms that have only one target.)\n//\n// - First comes the amount of terms in the table\n//\n// - Then, for each term, the offset of the term's data\n//\n// - At these offsets, there's a record for each target state\n//\n//   - Such a record starts with the amount of start states that go to\n//     this target state, shifted one to the left, with the first bit\n//     only set if this is the last record for this term.\n//\n//   - Then follows the target state id\n//\n//   - And then the start state ids\nfunction computeGotoTable(states) {\n    let goto = {};\n    let maxTerm = 0;\n    for (let state of states) {\n        for (let entry of state.goto) {\n            maxTerm = Math.max(entry.term.id, maxTerm);\n            let set = goto[entry.term.id] || (goto[entry.term.id] = {});\n            (set[entry.target.id] || (set[entry.target.id] = [])).push(state.id);\n        }\n    }\n    let data = new DataBuilder;\n    let index = [];\n    let offset = maxTerm + 2; // Offset of the data, taking index size into account\n    for (let term = 0; term <= maxTerm; term++) {\n        let entries = goto[term];\n        if (!entries) {\n            index.push(1);\n            continue;\n        }\n        let termTable = [];\n        let keys = Object.keys(entries);\n        for (let target of keys) {\n            let list = entries[target];\n            termTable.push((target == keys[keys.length - 1] ? 1 : 0) + (list.length << 1));\n            termTable.push(+target);\n            for (let source of list)\n                termTable.push(source);\n        }\n        index.push(data.storeArray(termTable) + offset);\n    }\n    if (index.some(n => n > 0xffff))\n        throw new GenError(\"Goto table too large\");\n    return Uint16Array.from([maxTerm + 1, ...index, ...data.data]);\n}\nclass TokenGroup {\n    constructor(tokens, groupID) {\n        this.tokens = tokens;\n        this.groupID = groupID;\n    }\n    create() { return this.groupID; }\n    createSource() { return String(this.groupID); }\n}\nfunction addToSet(set, value) {\n    if (!set.includes(value))\n        set.push(value);\n}\nfunction buildTokenMasks(groups) {\n    let masks = Object.create(null);\n    for (let group of groups) {\n        let groupMask = 1 << group.groupID;\n        for (let term of group.tokens) {\n            masks[term.id] = (masks[term.id] || 0) | groupMask;\n        }\n    }\n    return masks;\n}\nclass TokenArg {\n    constructor(name, expr, scope) {\n        this.name = name;\n        this.expr = expr;\n        this.scope = scope;\n    }\n}\nclass BuildingRule {\n    constructor(name, start, to, args) {\n        this.name = name;\n        this.start = start;\n        this.to = to;\n        this.args = args;\n    }\n}\nclass TokenSet {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.startState = new State$1;\n        this.built = [];\n        this.building = []; // Used for recursion check\n        this.byDialect = Object.create(null);\n        this.precedenceRelations = [];\n        this.rules = ast ? ast.rules : none;\n        for (let rule of this.rules)\n            b.unique(rule.id);\n    }\n    getToken(expr) {\n        for (let built of this.built)\n            if (built.matches(expr))\n                return built.term;\n        let name = expr.id.name;\n        let rule = this.rules.find(r => r.id.name == name);\n        if (!rule)\n            return null;\n        let { name: nodeName, props, dialect, exported } = this.b.nodeInfo(rule.props, \"d\", name, expr.args, rule.params.length != expr.args.length ? none : rule.params);\n        let term = this.b.makeTerminal(expr.toString(), nodeName, props);\n        if (dialect != null)\n            (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);\n        if ((term.nodeType || exported) && rule.params.length == 0) {\n            if (!term.nodeType)\n                term.preserve = true;\n            this.b.namedTerms[exported || name] = term;\n        }\n        this.buildRule(rule, expr, this.startState, new State$1([term]));\n        this.built.push(new BuiltRule(name, expr.args, term));\n        return term;\n    }\n    buildRule(rule, expr, from, to, args = none) {\n        let name = expr.id.name;\n        if (rule.params.length != expr.args.length)\n            this.b.raise(`Incorrect number of arguments for token '${name}'`, expr.start);\n        let building = this.building.find(b => b.name == name && exprsEq(expr.args, b.args));\n        if (building) {\n            if (building.to == to) {\n                from.nullEdge(building.start);\n                return;\n            }\n            let lastIndex = this.building.length - 1;\n            while (this.building[lastIndex].name != name)\n                lastIndex--;\n            this.b.raise(`Invalid (non-tail) recursion in token rules: ${this.building.slice(lastIndex).map(b => b.name).join(\" -> \")}`, expr.start);\n        }\n        this.b.used(rule.id.name);\n        let start = new State$1;\n        from.nullEdge(start);\n        this.building.push(new BuildingRule(name, start, to, expr.args));\n        this.build(this.b.substituteArgs(rule.expr, expr.args, rule.params), start, to, expr.args.map((e, i) => new TokenArg(rule.params[i].name, e, args)));\n        this.building.pop();\n    }\n    build(expr, from, to, args) {\n        if (expr instanceof NameExpression) {\n            let name = expr.id.name, arg = args.find(a => a.name == name);\n            if (arg)\n                return this.build(arg.expr, from, to, arg.scope);\n            let rule;\n            for (let i = 0, lt = this.b.localTokens; i <= lt.length; i++) {\n                let set = i == lt.length ? this.b.tokens : lt[i];\n                rule = set.rules.find(r => r.id.name == name);\n            }\n            if (!rule)\n                return this.b.raise(`Reference to token rule '${expr.id.name}', which isn't found`, expr.start);\n            this.buildRule(rule, expr, from, to, args);\n        }\n        else if (expr instanceof CharClass) {\n            for (let [a, b] of CharClasses[expr.type])\n                from.edge(a, b, to);\n        }\n        else if (expr instanceof ChoiceExpression) {\n            for (let choice of expr.exprs)\n                this.build(choice, from, to, args);\n        }\n        else if (isEmpty(expr)) {\n            from.nullEdge(to);\n        }\n        else if (expr instanceof SequenceExpression) {\n            let conflict = expr.markers.find(c => c.length > 0);\n            if (conflict)\n                this.b.raise(\"Conflict marker in token expression\", conflict[0].start);\n            for (let i = 0; i < expr.exprs.length; i++) {\n                let next = i == expr.exprs.length - 1 ? to : new State$1;\n                this.build(expr.exprs[i], from, next, args);\n                from = next;\n            }\n        }\n        else if (expr instanceof RepeatExpression) {\n            if (expr.kind == \"*\") {\n                let loop = new State$1;\n                from.nullEdge(loop);\n                this.build(expr.expr, loop, loop, args);\n                loop.nullEdge(to);\n            }\n            else if (expr.kind == \"+\") {\n                let loop = new State$1;\n                this.build(expr.expr, from, loop, args);\n                this.build(expr.expr, loop, loop, args);\n                loop.nullEdge(to);\n            }\n            else { // expr.kind == \"?\"\n                from.nullEdge(to);\n                this.build(expr.expr, from, to, args);\n            }\n        }\n        else if (expr instanceof SetExpression) {\n            for (let [a, b] of expr.inverted ? invertRanges(expr.ranges) : expr.ranges)\n                rangeEdges(from, to, a, b);\n        }\n        else if (expr instanceof LiteralExpression) {\n            for (let i = 0; i < expr.value.length; i++) {\n                let ch = expr.value.charCodeAt(i);\n                let next = i == expr.value.length - 1 ? to : new State$1;\n                from.edge(ch, ch + 1, next);\n                from = next;\n            }\n        }\n        else if (expr instanceof AnyExpression) {\n            let mid = new State$1;\n            from.edge(0, 0xDC00, to);\n            from.edge(0xDC00, MAX_CHAR + 1, to);\n            from.edge(0xD800, 0xDC00, mid);\n            mid.edge(0xDC00, 0xE000, to);\n        }\n        else {\n            return this.b.raise(`Unrecognized expression type in token`, expr.start);\n        }\n    }\n    takePrecedences() {\n        let rel = this.precedenceRelations = [];\n        if (this.ast)\n            for (let group of this.ast.precedences) {\n                let prev = [];\n                for (let item of group.items) {\n                    let level = [];\n                    if (item instanceof NameExpression) {\n                        for (let built of this.built)\n                            if (item.args.length ? built.matches(item) : built.id == item.id.name)\n                                level.push(built.term);\n                    }\n                    else {\n                        let id = JSON.stringify(item.value), found = this.built.find(b => b.id == id);\n                        if (found)\n                            level.push(found.term);\n                    }\n                    if (!level.length)\n                        this.b.warn(`Precedence specified for unknown token ${item}`, item.start);\n                    for (let term of level)\n                        addRel(rel, term, prev);\n                    prev = prev.concat(level);\n                }\n            }\n    }\n    precededBy(a, b) {\n        let found = this.precedenceRelations.find(r => r.term == a);\n        return found && found.after.includes(b);\n    }\n    buildPrecTable(softConflicts) {\n        let precTable = [], rel = this.precedenceRelations.slice();\n        // Add entries for soft-conflicting tokens that are in the\n        // precedence table, to make sure they'll appear in the right\n        // order and don't mess up the longer-wins default rule.\n        for (let { a, b, soft } of softConflicts)\n            if (soft) {\n                if (!rel.some(r => r.term == a) || !rel.some(r => r.term == b))\n                    continue;\n                if (soft < 0)\n                    [a, b] = [b, a]; // Now a is longer than b (and should thus take precedence)\n                addRel(rel, b, [a]);\n                addRel(rel, a, []);\n            }\n        add: while (rel.length) {\n            for (let i = 0; i < rel.length; i++) {\n                let record = rel[i];\n                if (record.after.every(t => precTable.includes(t.id))) {\n                    precTable.push(record.term.id);\n                    if (rel.length == 1)\n                        break add;\n                    rel[i] = rel.pop();\n                    continue add;\n                }\n            }\n            this.b.raise(`Cyclic token precedence relation between ${rel.map(r => r.term).join(\", \")}`);\n        }\n        return precTable;\n    }\n}\nclass MainTokenSet extends TokenSet {\n    constructor() {\n        super(...arguments);\n        this.explicitConflicts = [];\n    }\n    getLiteral(expr) {\n        let id = JSON.stringify(expr.value);\n        for (let built of this.built)\n            if (built.id == id)\n                return built.term;\n        let name = null, props = {}, dialect = null, exported = null;\n        let decl = this.ast ? this.ast.literals.find(l => l.literal == expr.value) : null;\n        if (decl)\n            ({ name, props, dialect, exported } = this.b.nodeInfo(decl.props, \"da\", expr.value));\n        let term = this.b.makeTerminal(id, name, props);\n        if (dialect != null)\n            (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);\n        if (exported)\n            this.b.namedTerms[exported] = term;\n        this.build(expr, this.startState, new State$1([term]), none);\n        this.built.push(new BuiltRule(id, none, term));\n        return term;\n    }\n    takeConflicts() {\n        var _a;\n        let resolve = (expr) => {\n            if (expr instanceof NameExpression) {\n                for (let built of this.built)\n                    if (built.matches(expr))\n                        return built.term;\n            }\n            else {\n                let id = JSON.stringify(expr.value), found = this.built.find(b => b.id == id);\n                if (found)\n                    return found.term;\n            }\n            this.b.warn(`Precedence specified for unknown token ${expr}`, expr.start);\n            return null;\n        };\n        for (let c of ((_a = this.ast) === null || _a === void 0 ? void 0 : _a.conflicts) || []) {\n            let a = resolve(c.a), b = resolve(c.b);\n            if (a && b) {\n                if (a.id < b.id)\n                    [a, b] = [b, a];\n                this.explicitConflicts.push({ a, b });\n            }\n        }\n    }\n    // Token groups are a mechanism for allowing conflicting (matching\n    // overlapping input, without an explicit precedence being given)\n    // tokens to exist in a grammar _if_ they don't occur in the same\n    // place (aren't used in the same states).\n    //\n    // States that use tokens that conflict will raise an error when any\n    // of the conflicting pairs of tokens both occur in that state.\n    // Otherwise, they are assigned a token group, which includes all\n    // the potentially-conflicting tokens they use. If there's already a\n    // group that doesn't have any conflicts with those tokens, that is\n    // reused, otherwise a new group is created.\n    //\n    // So each state has zero or one token groups, and each conflicting\n    // token may belong to one or more groups. Tokens get assigned a\n    // 16-bit bitmask with the groups they belong to set to 1 (all-1s\n    // for non-conflicting tokens). When tokenizing, that mask is\n    // compared to the current state's group (again using all-1s for\n    // group-less states) to determine whether a token is applicable for\n    // this state.\n    //\n    // Extended/specialized tokens are treated as their parent token for\n    // this purpose.\n    buildTokenGroups(states, skipInfo, startID) {\n        let tokens = this.startState.compile();\n        if (tokens.accepting.length)\n            this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r => r.id.name == tokens.accepting[0].name).start);\n        if (/\\btokens\\b/.test(verbose))\n            console.log(tokens.toString());\n        // If there is a precedence specified for the pair, the conflict is resolved\n        let allConflicts = tokens.findConflicts(checkTogether(states, this.b, skipInfo))\n            .filter(({ a, b }) => !this.precededBy(a, b) && !this.precededBy(b, a));\n        for (let { a, b } of this.explicitConflicts) {\n            if (!allConflicts.some(c => c.a == a && c.b == b))\n                allConflicts.push(new Conflict$1(a, b, 0, \"\", \"\"));\n        }\n        let softConflicts = allConflicts.filter(c => c.soft), conflicts = allConflicts.filter(c => !c.soft);\n        let errors = [];\n        let groups = [];\n        for (let state of states) {\n            if (state.defaultReduce || state.tokenGroup > -1)\n                continue;\n            // Find potentially-conflicting terms (in terms) and the things\n            // they conflict with (in conflicts), and raise an error if\n            // there's a token conflict directly in this state.\n            let terms = [], incompatible = [];\n            let skip = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens;\n            for (let term of skip)\n                if (state.actions.some(a => a.term == term))\n                    this.b.raise(`Use of token ${term.name} conflicts with skip rule`);\n            let stateTerms = [];\n            for (let i = 0; i < state.actions.length + (skip ? skip.length : 0); i++) {\n                let term = i < state.actions.length ? state.actions[i].term : skip[i - state.actions.length];\n                let orig = this.b.tokenOrigins[term.name];\n                if (orig && orig.spec)\n                    term = orig.spec;\n                else if (orig && orig.external)\n                    continue;\n                addToSet(stateTerms, term);\n            }\n            if (stateTerms.length == 0)\n                continue;\n            for (let term of stateTerms) {\n                for (let conflict of conflicts) {\n                    let conflicting = conflict.a == term ? conflict.b : conflict.b == term ? conflict.a : null;\n                    if (!conflicting)\n                        continue;\n                    if (stateTerms.includes(conflicting) && !errors.some(e => e.conflict == conflict)) {\n                        let example = conflict.exampleA ? ` (example: ${JSON.stringify(conflict.exampleA)}${conflict.exampleB ? ` vs ${JSON.stringify(conflict.exampleB)}` : \"\"})` : \"\";\n                        errors.push({\n                            error: `Overlapping tokens ${term.name} and ${conflicting.name} used in same context${example}\\n` +\n                                `After: ${state.set[0].trail()}`,\n                            conflict\n                        });\n                    }\n                    addToSet(terms, term);\n                    addToSet(incompatible, conflicting);\n                }\n            }\n            let tokenGroup = null;\n            for (let group of groups) {\n                if (incompatible.some(term => group.tokens.includes(term)))\n                    continue;\n                for (let term of terms)\n                    addToSet(group.tokens, term);\n                tokenGroup = group;\n                break;\n            }\n            if (!tokenGroup) {\n                tokenGroup = new TokenGroup(terms, groups.length + startID);\n                groups.push(tokenGroup);\n            }\n            state.tokenGroup = tokenGroup.groupID;\n        }\n        if (errors.length)\n            this.b.raise(errors.map(e => e.error).join(\"\\n\\n\"));\n        if (groups.length + startID > 16)\n            this.b.raise(`Too many different token groups (${groups.length}) to represent them as a 16-bit bitfield`);\n        let precTable = this.buildPrecTable(softConflicts);\n        return {\n            tokenGroups: groups,\n            tokenPrec: precTable,\n            tokenData: tokens.toArray(buildTokenMasks(groups), precTable)\n        };\n    }\n}\nclass LocalTokenSet extends TokenSet {\n    constructor(b, ast) {\n        super(b, ast);\n        this.fallback = null;\n        if (ast.fallback)\n            b.unique(ast.fallback.id);\n    }\n    getToken(expr) {\n        let term = null;\n        if (this.ast.fallback && this.ast.fallback.id.name == expr.id.name) {\n            if (expr.args.length)\n                this.b.raise(`Incorrect number of arguments for ${expr.id.name}`, expr.start);\n            if (!this.fallback) {\n                let { name: nodeName, props, exported } = this.b.nodeInfo(this.ast.fallback.props, \"\", expr.id.name, none, none);\n                let term = this.fallback = this.b.makeTerminal(expr.id.name, nodeName, props);\n                if (term.nodeType || exported) {\n                    if (!term.nodeType)\n                        term.preserve = true;\n                    this.b.namedTerms[exported || expr.id.name] = term;\n                }\n                this.b.used(expr.id.name);\n            }\n            term = this.fallback;\n        }\n        else {\n            term = super.getToken(expr);\n        }\n        if (term && !this.b.tokenOrigins[term.name])\n            this.b.tokenOrigins[term.name] = { group: this };\n        return term;\n    }\n    buildLocalGroup(states, skipInfo, id) {\n        let tokens = this.startState.compile();\n        if (tokens.accepting.length)\n            this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r => r.id.name == tokens.accepting[0].name).start);\n        for (let { a, b, exampleA } of tokens.findConflicts(() => true)) {\n            if (!this.precededBy(a, b) && !this.precededBy(b, a))\n                this.b.raise(`Overlapping tokens ${a.name} and ${b.name} in local token group${exampleA ? ` (example: ${JSON.stringify(exampleA)})` : ''}`);\n        }\n        for (let state of states) {\n            if (state.defaultReduce)\n                continue;\n            // See if this state uses any of the tokens in this group, and\n            // if so, make sure it *only* uses tokens from this group.\n            let usesThis = null;\n            let usesOther = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens[0];\n            for (let { term } of state.actions) {\n                let orig = this.b.tokenOrigins[term.name];\n                if ((orig === null || orig === void 0 ? void 0 : orig.group) == this)\n                    usesThis = term;\n                else\n                    usesOther = term;\n            }\n            if (usesThis) {\n                if (usesOther)\n                    this.b.raise(`Tokens from a local token group used together with other tokens (${usesThis.name} with ${usesOther.name})`);\n                state.tokenGroup = id;\n            }\n        }\n        let precTable = this.buildPrecTable(none);\n        let tokenData = tokens.toArray({ [id]: 65535 /* Seq.End */ }, precTable);\n        let precOffset = tokenData.length;\n        let fullData = new Uint16Array(tokenData.length + precTable.length + 1);\n        fullData.set(tokenData, 0);\n        fullData.set(precTable, precOffset);\n        fullData[fullData.length - 1] = 65535 /* Seq.End */;\n        return {\n            groupID: id,\n            create: () => new LocalTokenGroup(fullData, precOffset, this.fallback ? this.fallback.id : undefined),\n            createSource: importName => `new ${importName(\"LocalTokenGroup\", \"@lezer/lr\")}(${encodeArray(fullData)}, ${precOffset}${this.fallback ? `, ${this.fallback.id}` : ''})`\n        };\n    }\n}\nfunction checkTogether(states, b, skipInfo) {\n    let cache = Object.create(null);\n    function hasTerm(state, term) {\n        return state.actions.some(a => a.term == term) ||\n            skipInfo[b.skipRules.indexOf(state.skip)].startTokens.includes(term);\n    }\n    return (a, b) => {\n        if (a.id < b.id)\n            [a, b] = [b, a];\n        let key = a.id | (b.id << 16), cached = cache[key];\n        if (cached != null)\n            return cached;\n        return cache[key] = states.some(state => hasTerm(state, a) && hasTerm(state, b));\n    };\n}\nfunction invertRanges(ranges) {\n    let pos = 0, result = [];\n    for (let [a, b] of ranges) {\n        if (a > pos)\n            result.push([pos, a]);\n        pos = b;\n    }\n    if (pos <= MAX_CODE)\n        result.push([pos, MAX_CODE + 1]);\n    return result;\n}\nconst ASTRAL = 0x10000, GAP_START = 0xd800, GAP_END = 0xe000, MAX_CODE = 0x10ffff;\nconst LOW_SURR_B = 0xdc00, HIGH_SURR_B = 0xdfff;\n// Create intermediate states for astral characters in a range, if\n// necessary, since the tokenizer acts on UTF16 characters\nfunction rangeEdges(from, to, low, hi) {\n    if (low < ASTRAL) {\n        if (low < GAP_START)\n            from.edge(low, Math.min(hi, GAP_START), to);\n        if (hi > GAP_END)\n            from.edge(Math.max(low, GAP_END), Math.min(hi, MAX_CHAR + 1), to);\n        low = ASTRAL;\n    }\n    if (hi <= ASTRAL)\n        return;\n    let lowStr = String.fromCodePoint(low), hiStr = String.fromCodePoint(hi - 1);\n    let lowA = lowStr.charCodeAt(0), lowB = lowStr.charCodeAt(1);\n    let hiA = hiStr.charCodeAt(0), hiB = hiStr.charCodeAt(1);\n    if (lowA == hiA) { // Share the first char code\n        let hop = new State$1;\n        from.edge(lowA, lowA + 1, hop);\n        hop.edge(lowB, hiB + 1, to);\n    }\n    else {\n        let midStart = lowA, midEnd = hiA;\n        if (lowB > LOW_SURR_B) {\n            midStart++;\n            let hop = new State$1;\n            from.edge(lowA, lowA + 1, hop);\n            hop.edge(lowB, HIGH_SURR_B + 1, to);\n        }\n        if (hiB < HIGH_SURR_B) {\n            midEnd--;\n            let hop = new State$1;\n            from.edge(hiA, hiA + 1, hop);\n            hop.edge(LOW_SURR_B, hiB + 1, to);\n        }\n        if (midStart <= midEnd) {\n            let hop = new State$1;\n            from.edge(midStart, midEnd + 1, hop);\n            hop.edge(LOW_SURR_B, HIGH_SURR_B + 1, to);\n        }\n    }\n}\nfunction isEmpty(expr) {\n    return expr instanceof SequenceExpression && expr.exprs.length == 0;\n}\nfunction gatherExtTokens(b, tokens) {\n    let result = Object.create(null);\n    for (let token of tokens) {\n        b.unique(token.id);\n        let { name, props, dialect } = b.nodeInfo(token.props, \"d\", token.id.name);\n        let term = b.makeTerminal(token.id.name, name, props);\n        if (dialect != null)\n            (b.tokens.byDialect[dialect] || (b.tokens.byDialect[dialect] = [])).push(term);\n        b.namedTerms[token.id.name] = result[token.id.name] = term;\n    }\n    return result;\n}\nfunction findExtToken(b, tokens, expr) {\n    let found = tokens[expr.id.name];\n    if (!found)\n        return null;\n    if (expr.args.length)\n        b.raise(\"External tokens cannot take arguments\", expr.args[0].start);\n    b.used(expr.id.name);\n    return found;\n}\nfunction addRel(rel, term, after) {\n    let found = rel.findIndex(r => r.term == term);\n    if (found < 0)\n        rel.push({ term, after });\n    else\n        rel[found] = { term, after: rel[found].after.concat(after) };\n}\nclass ExternalTokenSet {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.tokens = gatherExtTokens(b, ast.tokens);\n        for (let name in this.tokens)\n            this.b.tokenOrigins[this.tokens[name].name] = { external: this };\n    }\n    getToken(expr) { return findExtToken(this.b, this.tokens, expr); }\n    create() {\n        return this.b.options.externalTokenizer(this.ast.id.name, this.b.termTable);\n    }\n    createSource(importName) {\n        let { source, id: { name } } = this.ast;\n        return importName(name, source);\n    }\n}\nclass ExternalSpecializer {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.term = null;\n        this.tokens = gatherExtTokens(b, ast.tokens);\n    }\n    finish() {\n        let terms = this.b.normalizeExpr(this.ast.token);\n        if (terms.length != 1 || terms[0].terms.length != 1 || !terms[0].terms[0].terminal)\n            this.b.raise(`The token expression to '@external ${this.ast.type}' must resolve to a token`, this.ast.token.start);\n        this.term = terms[0].terms[0];\n        for (let name in this.tokens)\n            this.b.tokenOrigins[this.tokens[name].name] = { spec: this.term, external: this };\n    }\n    getToken(expr) { return findExtToken(this.b, this.tokens, expr); }\n}\nfunction inlineRules(rules, preserve) {\n    for (let pass = 0;; pass++) {\n        let inlinable = Object.create(null), found;\n        if (pass == 0)\n            for (let rule of rules) {\n                if (rule.name.inline && !inlinable[rule.name.name]) {\n                    let group = rules.filter(r => r.name == rule.name);\n                    if (group.some(r => r.parts.includes(rule.name)))\n                        continue;\n                    found = inlinable[rule.name.name] = group;\n                }\n            }\n        for (let i = 0; i < rules.length; i++) {\n            let rule = rules[i];\n            if (!rule.name.interesting && !rule.parts.includes(rule.name) && rule.parts.length < 3 &&\n                !preserve.includes(rule.name) &&\n                (rule.parts.length == 1 || rules.every(other => other.skip == rule.skip || !other.parts.includes(rule.name))) &&\n                !rule.parts.some(p => !!inlinable[p.name]) &&\n                !rules.some((r, j) => j != i && r.name == rule.name))\n                found = inlinable[rule.name.name] = [rule];\n        }\n        if (!found)\n            return rules;\n        let newRules = [];\n        for (let rule of rules) {\n            if (inlinable[rule.name.name])\n                continue;\n            if (!rule.parts.some(p => !!inlinable[p.name])) {\n                newRules.push(rule);\n                continue;\n            }\n            function expand(at, conflicts, parts) {\n                if (at == rule.parts.length) {\n                    newRules.push(new Rule(rule.name, parts, conflicts, rule.skip));\n                    return;\n                }\n                let next = rule.parts[at], replace = inlinable[next.name];\n                if (!replace) {\n                    expand(at + 1, conflicts.concat(rule.conflicts[at + 1]), parts.concat(next));\n                    return;\n                }\n                for (let r of replace)\n                    expand(at + 1, conflicts.slice(0, conflicts.length - 1)\n                        .concat(conflicts[at].join(r.conflicts[0]))\n                        .concat(r.conflicts.slice(1, r.conflicts.length - 1))\n                        .concat(rule.conflicts[at + 1].join(r.conflicts[r.conflicts.length - 1])), parts.concat(r.parts));\n            }\n            expand(0, [rule.conflicts[0]], []);\n        }\n        rules = newRules;\n    }\n}\nfunction mergeRules(rules) {\n    let merged = Object.create(null), found;\n    for (let i = 0; i < rules.length;) {\n        let groupStart = i;\n        let name = rules[i++].name;\n        while (i < rules.length && rules[i].name == name)\n            i++;\n        let size = i - groupStart;\n        if (name.interesting)\n            continue;\n        for (let j = i; j < rules.length;) {\n            let otherStart = j, otherName = rules[j++].name;\n            while (j < rules.length && rules[j].name == otherName)\n                j++;\n            if (j - otherStart != size || otherName.interesting)\n                continue;\n            let match = true;\n            for (let k = 0; k < size && match; k++) {\n                let a = rules[groupStart + k], b = rules[otherStart + k];\n                if (a.cmpNoName(b) != 0)\n                    match = false;\n            }\n            if (match)\n                found = merged[name.name] = otherName;\n        }\n    }\n    if (!found)\n        return rules;\n    let newRules = [];\n    for (let rule of rules)\n        if (!merged[rule.name.name]) {\n            newRules.push(rule.parts.every(p => !merged[p.name]) ? rule :\n                new Rule(rule.name, rule.parts.map(p => merged[p.name] || p), rule.conflicts, rule.skip));\n        }\n    return newRules;\n}\nfunction simplifyRules(rules, preserve) {\n    return mergeRules(inlineRules(rules, preserve));\n}\n/// Build an in-memory parser instance for a given grammar. This is\n/// mostly useful for testing. If your grammar uses external\n/// tokenizers, you'll have to provide the `externalTokenizer` option\n/// for the returned parser to be able to parse anything.\nfunction buildParser(text, options = {}) {\n    let builder = new Builder(text, options), parser = builder.getParser();\n    parser.termTable = builder.termTable;\n    return parser;\n}\nconst KEYWORDS = [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\",\n    \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"while\", \"with\",\n    \"null\", \"true\", \"false\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"new\", \"in\", \"this\",\n    \"const\", \"class\", \"extends\", \"export\", \"import\", \"super\", \"enum\", \"implements\", \"interface\",\n    \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"require\"];\n/// Build the code that represents the parser tables for a given\n/// grammar description. The `parser` property in the return value\n/// holds the main file that exports the `Parser` instance. The\n/// `terms` property holds a declaration file that defines constants\n/// for all of the named terms in grammar, holding their ids as value.\n/// This is useful when external code, such as a tokenizer, needs to\n/// be able to use these ids. It is recommended to run a tree-shaking\n/// bundler when importing this file, since you usually only need a\n/// handful of the many terms in your code.\nfunction buildParserFile(text, options = {}) {\n    return new Builder(text, options).getParserFile();\n}\nfunction ignored(name) {\n    let first = name[0];\n    return first == \"_\" || first.toUpperCase() != first;\n}\nfunction isExported(rule) {\n    return rule.props.some(p => p.at && p.name == \"export\");\n}\n\nexport { GenError, buildParser, buildParserFile };\n"],"names":["Node","constructor","start","this","GrammarDeclaration","rules","topRules","tokens","localTokens","context","externalTokens","externalSpecializers","externalPropSources","precedences","mainSkip","scopedSkip","dialects","externalProps","autoDelim","super","toString","Object","values","join","RuleDeclaration","id","props","params","expr","name","length","PrecDeclaration","items","TokenPrecDeclaration","TokenConflictDeclaration","a","b","TokenDeclaration","conflicts","literals","LocalTokenDeclaration","fallback","LiteralDeclaration","literal","ContextDeclaration","source","ExternalTokenDeclaration","ExternalSpecializeDeclaration","type","token","ExternalPropSourceDeclaration","ExternalPropDeclaration","externalID","Identifier","Expression","walk","f","eq","_other","prototype","prec","NameExpression","args","other","exprsEq","walkExprs","SpecializeExpression","content","Prop","eqProps","exprEq","InlineRuleExpression","rule","oRule","ChoiceExpression","exprs","map","e","maybeParens","SequenceExpression","markers","empty","every","m","i","om","x","ConflictMarker","RepeatExpression","kind","LiteralExpression","value","JSON","stringify","SetExpression","ranges","inverted","String","fromCodePoint","y","AnyExpression","result","slice","push","CharClasses","asciiLetter","asciiLowercase","asciiUppercase","digit","whitespace","eof","CharClass","at","v","test","p","PropPart","node","parent","GenError","Error","hasProps","_p","termHash","Term","flags","nodeName","hash","nodeType","top","repeated","terminal","error","interesting","preserve","inline","cmp","TermSet","terms","names","create","tops","term","makeTop","makeTerminal","makeNonTerminal","makeRepeat","uniqueName","cur","finish","filter","t","some","r","parts","includes","nodeTypes","nextID","minRepeatTerm","maxTerm","cmpSet","diff","none$3","Conflicts","precedence","ambigGroups","cut","none","Math","max","union","sort","ruleID","Rule","skip","cmpNoName","reduce","s","isRepeatWrap","sameReduce","Edge","from","to","target","charFor","n","fromCharCode","isEquivalent","partition","edges","eA","eB","applyMinimization","states","state","edge","stateID","State$1","accepting","nullEdge","compile","labeled","localID","startState","explore","newState","ids","out","transitions","separate","found","closure","MergedEdge","mergeEdges","merged","targets","byAccepting","group","split","newPartition","groups","minimize","seen","sameSet$1","findConflicts","occurTogether","cycleTerms","add","soft","aEdges","bEdges","find","c","Conflict$1","exampleFromEdges","reachable","j","es","hasCycle","orig","concat","work","table","Map","haveCycle","entry","get","set","next","pop","toArray","groupMasks","offsets","data","acceptEnd","stateMask","indexOf","Uint16Array","mask","exampleA","exampleB","str","elts","elt","word","_","none$2","Input","string","fileName","end","lineInfo","pos","line","ch","message","msg","posInfo","info","raise","match","re","exec","readString","lastIndex","eat","unexpected","expect","val","parse","input","external","specialized","propSources","sawTop","parseRule","parseIdent","parseTokens","parseLocalTokens","parseExternalTokens","parseExternalProp","parseExternalSpecialize","parseExternalPropSource","first","parsePrecedence","parseBracedExpr","parseGrammar","named","parseProps","parseProp","parseExprChoice","SET_MARKER","parseExprInner","invert","unescaped","replace","code","codePointAt","addRange","charCodeAt","hasOwnProperty","cls","parseArgs","parseExprSuffix","endOfSequence","parseExprSequence","markerType","localStart","ms","left","tokenRules","parseTokenPrecedence","parseTokenConflict","parseExternalTokenSet","point","all","u1","u2","u3","single","unknown","parseInt","hashString","h","verbose","process","env","LOG","timing","time","label","t0","Date","now","console","log","toFixed","_label","Pos","ahead","ambigAhead","skipAhead","via","advance","cmpStr","eqSimple","splice","sameSet","trail","maxLen","reverse","addOrigins","conflictsAt","compareRepeatPrec","posB","termsAhead","after","cont","addTo","eqSet","Shift","Reduce","mapping","mapped","hashPositions","State","startRule","actions","actionPositions","goto","tokenGroup","defaultReduce","g","addActionInner","positions","check","action","fullPos","actionFullPos","actionConflicts","addAction","conflict","conflictPos","root","hist","unshift","repeat","p2","findConflictOrigin","Conflict","getGoto","hasSet","dThis","dOther","array","Core","applyCut","canMergeInner","canMerge","mergeStates","newStates","newID","Group","origin","member","members","samePosSet","none$1","digitToChar","encode","low","rest","encodeArray","Parts","ensureConflicts","otherConflicts","withConflicts","BuiltRule","matches","matchesRepeat","Builder","text","options","tokenOrigins","built","ruleNames","namespaces","namedTerms","termTable","knownProps","dynamicRulePrecedences","definedGroups","astRules","currentSkip","ast","NP","NodeProp","prop","perNode","externalProp","d","MainTokenSet","LocalTokenSet","ext","ExternalTokenSet","decl","ExternalSpecializer","noSkip","newName","defineRule","scoped","findIndex","sc","isEmpty","unique","skipRules","normalizeExpr","used","nodeInfo","isExported","buildRule","warn","takePrecedences","takeConflicts","lt","defineGroup","checkGroups","base","prepareParser","groupStart","size","otherStart","otherName","k","newRules","mergeRules","pass","inlinable","expand","inlineRules","simplifyRules","termNames","startTerms","change","nt","startLen","part","computeFirstSets","skipInfo","startTokens","fullTable","cores","getState","core","coreHash","byHash","known","added","redo","addFor","existing","origIndex","startTerm","startSkip","filled","byTerm","byTermPos","atEnd","index","replaced","count","buildFullAutomaton","grp","buildLocalGroup","tokenGroups","tokenPrec","tokenData","buildTokenGroups","didMerge","mergeIdentical","assignGroups","spill","groupIndex","idA","idB","collapseAutomaton","skipState","startRules","nonSkip","findSkipStates","buildSpecializeTable","tokStart","tokenizer","tokenizers","DataBuilder","skipData","storeArray","Uint32Array","forceReductions","computeForceReductions","finishCx","FinishStateContext","byDialect","dynamicPrecedences","precTable","nodeProps","skippedTypes","gatherNodeProps","stateData","computeGotoTable","nodeNames","repeatNodeCount","getParser","rawNodeProps","rawSpecialized","externalSpecializer","stack","extend","deserialize","version","externalPropSource","undefined","skippedNodes","tok","contextTracker","getParserFile","rawTokenizers","rawDialects","mod","moduleStyle","gen","head","imports","imported","defined","KEYWORDS","exportName","getName","prefix","importName","spec","src","varName","lrParser","createSource","serializePropValue","specHead","tableName","keys","key","parserStr","includeNames","parser","gatherNonSkippedNodes","forEach","notSkipped","rec","tag","reductions","candidates","gotoEdges","o","parents","length1Reductions","createsCycle","parentIntersection","reduceAction","setSize","done","substituteArgs","arg","substituteArgsInProps","substituteInValue","conflictsFor","here","marker","precs","item","choices","choice","resolve","getToken","normalizeRepeat","normalizeSequence","builder","complete","endConflicts","full","getLiteral","resolveSpecialization","dynamicPrec","explicitInline","exported","registerDynamicPrec","allow","defaultName","defaultProps","toUpperCase","ignored","dialect","finishProp","dialectID","builtin","delim","findDelimiters","addToProp","param","sp","findToken","lastToken","bracket","firstToken","_a","recur","getNamed","stateArray","sharedActions","findSharedActions","shared","scratch","fill","addr","storeActions","skipReduce","isSkip","forcedReduce","skipID","skipTable","skipTerms","addToSet","tokenizerMask","groupID","depth","search","findArray","num","offset","entries","list","TokenGroup","buildTokenMasks","masks","groupMask","TokenArg","scope","BuildingRule","TokenSet","building","precedenceRelations","build","loop","MAX_CODE","invertRanges","rangeEdges","mid","MAX_CHAR","rel","prev","level","addRel","precededBy","buildPrecTable","softConflicts","record","arguments","explicitConflicts","l","startID","allConflicts","cache","hasTerm","cached","checkTogether","errors","incompatible","stateTerms","conflicting","example","usesThis","usesOther","precOffset","fullData","ASTRAL","GAP_START","GAP_END","LOW_SURR_B","HIGH_SURR_B","hi","min","lowStr","hiStr","lowA","lowB","hiA","hiB","hop","midStart","midEnd","gatherExtTokens","findExtToken","externalTokenizer","buildParser"],"sourceRoot":""}