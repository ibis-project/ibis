{
  "hash": "3cc37f15ac28bf8c58eb319a09568b09",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Does Ibis understand SQL?\"\nauthor: \"Deepyaman Datta\"\ndate: \"2025-02-06\"\nimage: thumbnail.webp\ncategories:\n    - blog\n    - internals\n    - sql\n---\n\nLast month, an [insightful article on the dbt Developer Blog on what SQL comprehension really means](https://docs.getdbt.com/blog/the-levels-of-sql-comprehension)\ncame across my LinkedIn feed. The big deal about SDF is that it, unlike dbt, actually _understands_\nSQL. As an Ibis user and contributor, several of the concepts covered in the post were familiar—in\nfact, I first learned about Ibis because the product I was working on required an\n[intermediate representation](https://en.wikipedia.org/wiki/Intermediate_representation) that could\nbe compiled to Flink SQL code. In that case, as a dataframe library that interfaces with databases,\ndoes Ibis also understand SQL?\n\n## Tl;dr\n\nIbis doesn't understand SQL per se, but it does understand what you're trying to do. Ibis, much like\nSQL, defines a standardized interface for working with databases. Because Ibis understands queries\nexpressed through this user interface, it also provides users with some of the unique capabilities\nSDF offers, including the ability to execute said logic on the backend of the user's choice.\n\n## How does Ibis work?\n\nTo answer the question of whether Ibis understands SQL, we first need to understand the internals of\nIbis. Specifically, how is the code that users write with Ibis eventually executed on a SQL backend?\n\n### Building an expression\n\nIbis provides a dataframe API for writing expressions. A\n[follow-up article on the dbt Developer Blog on the key technologies behind SQL comprehension](https://docs.getdbt.com/blog/sql-comprehension-technologies)\nused the following SQL query in illustrating what the parser and compiler do:\n\n```sql\nselect x as u from t where x > 0\n```\n\nIn SQL, the _binder_ adds type information to the syntax tree produced by the _parser_. This order\nof operations differs from the way Ibis works; in Ibis, [`Node`](../../concepts/internals.qmd#the-ibis.expr.types.node-class)s—\nthe core operations that can be applied to expressions, such as `ibis.expr.operations.Add` and\n`ibis.expr.operations.WindowFunction`—must be applied to [`Expr`](../../concepts/internals.qmd#the-expr-class)\nobjects containing data type and shape information.\n\nThe [`Table`](../../reference/expression-tables.qmd#ibis.expr.types.relations.Table) is one of the\ncore Ibis data structures, analogous to a SQL table. It's also an `Expr` subclass. We begin by\nmanually defining a `Table` with our desired schema here, but one can also construct a table from an\nexisting database table, file, or in-memory data representation:\n\n::: {#830dc91c .cell execution_count=1}\n``` {.python .cell-code}\nimport ibis\n\nt = ibis.table(dict(x=\"int32\", y=\"float\", z=\"string\"), name=\"t\")\n```\n:::\n\n\nNext, we apply a filter and rename the `x` column as in the SQL query above:\n\n::: {#7b29a9e3 .cell execution_count=2}\n``` {.python .cell-code}\nexpr = t.filter(t.x > 0).select(t.x.name(\"u\"))\n```\n:::\n\n\nIn SQL, the _parser_ translates the query into a syntax tree, but in Ibis, expressions are\ninherently represented as a tree of `Expr` and `Node` objects. Ibis enables users to [`visualize()`](../../reference/expression-tables.qmd#ibis.expr.types.relations.Table.visualize)\nthis intermediate representation for any expression:\n\n::: {#9ab3ff61 .cell execution_count=3}\n``` {.python .cell-code}\nfrom ibis.expr.visualize import to_graph\n\nto_graph(expr)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](index_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\nIn non-interactive mode, pretty-printing the expression yields an equivalent textual representation:\n\n::: {#ab2eb270 .cell execution_count=4}\n``` {.python .cell-code}\nexpr\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\">r0 := UnboundTable: t\n  x int32\n  y float64\n  z string\n\nr1 := Filter[r0]\n  r0.x &gt; 0\n\nProject[r1]\n  u: r1.x\n</pre>\n```\n:::\n:::\n\n\nLook at that! Unsurprisingly, the resulting `repr()` matches the generated logical plan from the SQL\ncomprehension technologies article:\n\n![](logical_plan.png)\n\nNote that the abstract syntax tree is an artifact of the parsing step and has no direct Ibis analog.\n\n### Compiling the expression\n\nIn the past, Ibis would compile expressions to SQL using its own SQL generation logic. However, with\nthe [completion of \"the big refactor\" in Ibis 9.0](https://ibis-project.org/posts/ibis-version-9.0.0-release/),\nIbis fully transitioned to producing [SQLGlot](https://github.com/tobymao/sqlglot) expressions under\nthe hood.\n\nWe can see the intermediate SQLGlot representation of our expression using the `to_sqlglot()` method\non an Ibis backend compiler implementation:\n\n::: {#a7a3d766 .cell execution_count=5}\n``` {.python .cell-code}\nfrom ibis.backends.sql.compilers.duckdb import compiler\n\nquery = compiler.to_sqlglot(expr)\nquery\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nSelect(\n  expressions=[\n    Alias(\n      this=Column(\n        this=Identifier(this='x', quoted=True),\n        table=Identifier(this='t0', quoted=True)),\n      alias=Identifier(this='u', quoted=True))],\n  from=From(\n    this=Table(\n      this=Identifier(this='t', quoted=True),\n      alias=Identifier(this='t0', quoted=True))),\n  where=Where(\n    this=GT(\n      this=Column(\n        this=Identifier(this='x', quoted=True),\n        table=Identifier(this='t0', quoted=True)),\n      expression=Literal(this=0, is_string=False))))\n```\n:::\n:::\n\n\nIbis delegates SQL generation to SQLGlot, essentially calling the `sql()` method on the above query:\n\n::: {#2c34887d .cell execution_count=6}\n``` {.python .cell-code}\nquery.sql()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n'SELECT \"t0\".\"x\" AS \"u\" FROM \"t\" AS \"t0\" WHERE \"t0\".\"x\" > 0'\n```\n:::\n:::\n\n\nIbis also provides a top-level [`to_sql()`](../../reference/expression-generic.qmd#ibis.to_sql)\nmethod, so most users don't need to be aware of SQLGlot or the inner workings of Ibis expression\ncompilation—unless they want to:\n\n::: {#6ab89df4 .cell execution_count=7}\n``` {.python .cell-code}\nibis.to_sql(expr)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=7}\n```sql\nSELECT\n  \"t0\".\"x\" AS \"u\"\nFROM \"t\" AS \"t0\"\nWHERE\n  \"t0\".\"x\" > 0\n```\n:::\n:::\n\n\n::: {.callout-tip}\n## Why SQLGlot?\n\n[SQLGlot is a no-dependency SQL parser, transpiler, optimizer, and engine.](https://sqlglot.com/sqlglot.html)\nIt's a widely-used open-source project that powers the SQL comprehension and generation capabilities\nof tools like [SQLMesh](https://github.com/TobikoData/sqlmesh), [Apache Superset](https://github.com/apache/superset),\nand [Dagster](https://github.com/dagster-io/dagster). In fact, SQLGlot is also the engine behind the\ncolumn-level lineage feature available in dbt Cloud!\n\nThe specifics of why Ibis chose SQLGlot are beyond the scope of this article, but you can learn more\nabout the reasoning from a [GitHub discussion on moving the SQL backends from SQLAlchemy to SQLGlot](https://github.com/ibis-project/ibis/discussions/7213).\n:::\n\n### Executing the compiled expression\n\nExecution is the most straightforward part of the process. For most Ibis-supported SQL backends, the\n`execute()` method uses the database connection associated with the backend instance—usually managed\nby the underlying Python client library—to submit and fetch results for the compiled query. Last but\nnot least, Ibis massages the returned data into the desired format (e.g. a pandas DataFrame for easy\nconsumption). Because this final processing step falls outside the expression-understanding process,\nwe'll end our journey through the Ibis execution flow here.\n\nNote that the database still performs all of the activities covered by the SQL comprehension levels;\nthe database is completely oblivious to whatever Ibis did prior to providing the raw SQL to execute.\n\n## So, does Ibis understand SQL?\n\nIbis's expressive dataframe API lets users avoid writing handcrafted SQL queries in most situations,\nbut there are still cases where you may need to [use SQL strings in your Ibis code](../../how-to/extending/sql.qmd).\n[`Table.sql()`](../../reference/expression-tables.qmd#ibis.expr.types.relations.Table.sql) and\n[`Backend.sql()`](../../backends/duckdb.qmd#ibis.backends.duckdb.Backend.sql) work very similarly to\neach other. To explore both of these options, we'll need to initialize a backend connection (DuckDB\nworks perfectly for this purpose) and register our table:\n\n::: {#011020cb .cell execution_count=8}\n``` {.python .cell-code}\ncon = ibis.duckdb.connect()\nt = con.create_table(\"t\", t)\n```\n:::\n\n\nNow we can use the `Table.sql()` method to handle our SQL query:\n\n::: {#4be05874 .cell execution_count=9}\n``` {.python .cell-code}\nexpr = t.sql(\"select x as u from t where x > 0\")\nexpr\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\">r0 := DatabaseTable: memory.main.t\n  x int32\n  y float64\n  z string\n\nSQLStringView[r0]\n  query:\n    select x as u from t where x &gt; 0\n  schema:\n    u int32\n</pre>\n```\n:::\n:::\n\n\nNote that the expression tree doesn't have the same level of detail as the one we built using the\ndataframe API in the first section. Instead, a [`SQLStringView`](../../reference/operations.qmd#ibis.expr.operations.relations.SQLStringView)\nnode encapsulates the query. Ibis only understands the output schema for the operation, which it\nuses to validate any downstream operations.\n\nThe main difference between `Table.sql()` and `Backend.sql()` is that `Backend.sql()` can only refer\nto tables that already exist in the database. We see that reflected in the expression tree `repr()`;\nthe `DatabaseTable` node is not present in the `Backend.sql()` case, and a [`SQLQueryResult`](../../reference/operations.qmd#ibis.expr.operations.relations.SQLQueryResult)\nnode (that does not contain a reference to another Ibis relation) replaces the `SQLStringView` node:\n\n::: {#93b4feeb .cell execution_count=10}\n``` {.python .cell-code}\nexpr = con.sql(\"select x as u from t where x > 0\")\nexpr\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\">SQLQueryResult\n  query:\n    select x as u from t where x &gt; 0\n  schema:\n    u int32\n</pre>\n```\n:::\n:::\n\n\nThat said, the intermediate SQLGlot representations are identical for both alternatives:\n\n::: {#5e6e5ac2 .cell execution_count=11}\n``` {.python .cell-code}\ncon.compiler.to_sqlglot(expr)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nSelect(\n  expressions=[\n    Alias(\n      this=Column(\n        this=Identifier(this=x, quoted=False)),\n      alias=Identifier(this=u, quoted=False))],\n  from=From(\n    this=Table(\n      this=Identifier(this=t, quoted=False))),\n  where=Where(\n    this=GT(\n      this=Column(\n        this=Identifier(this=x, quoted=False)),\n      expression=Literal(this=0, is_string=False))))\n```\n:::\n:::\n\n\nIn fact, the resulting SQLGlot expression is only slightly, nonfunctionally different from the one\nwe got from the dataframe API. Similarly, the compiled SQL is identical except for the table alias:\n\n::: {#3e7f73df .cell execution_count=12}\n``` {.python .cell-code}\nibis.to_sql(expr)\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=12}\n```sql\nSELECT\n  x AS u\nFROM t\nWHERE\n  x > 0\n```\n:::\n:::\n\n\nIn short, while Ibis doesn't understand the inner structure of SQL queries passed to `Table.sql()`\nor `Backend.sql()`, it still compiles to SQLGlot expressions under the hood, which means SQLGlot's\ncapabilities (like producing column-level lineage) are still applicable.\n\nThe third option for writing SQL strings in Ibis, [`Backend.raw_sql()`](../../backends/duckdb.qmd#ibis.backends.duckdb.Backend.raw_sql),\nis opaque and only exists for situations where the user needs to run arbitrary SQL code. Ibis simply\nexecutes the code and returns the associated cursor; it does not attempt to understand the SQL.\n\n## Further reading\n\nIn this article, we explored how Ibis constructs expressions and compiles them to SQL using SQLGlot.\nEven as somebody who has contributed significantly to Ibis over the years, I learned a lot about the\ninner workings of the library. While it was too much to cover in a single blog post, I'll end with a\nfew resources I found interesting while drafting this article for those interested in diving deeper:\n\n- [Phillip Cloud on why Ibis moved away from SQLAlchemy to SQLGlot](https://github.com/ibis-project/ibis/discussions/7213)\n- [Toby Mao on the way SQLGlot computes column-level lineage](https://www.linkedin.com/posts/toby-mao_the-way-sqlglot-computes-column-level-lineage-activity-7166683013311852547-on21/)\n- [Krisztián Szűcs's PR that split the relational operations and created a new Ibis expression IR](https://github.com/ibis-project/ibis/pull/7752)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}