{
  "hash": "70c0ea98c3f68eb5616ab3ae7b0a4d41",
  "result": {
    "markdown": "---\ntitle: \"Ibis versus X: Performance across the ecosystem part 2\"\nauthor: \"Phillip Cloud\"\ndate: 2023-12-11\ncategories:\n  - blog\n  - case study\n  - ecosystem\n  - performance\n---\n\n**TL; DR**: Ibis supports both Polars and DataFusion. Both backends are have\nabout the same runtime performance, and lag far behind DuckDB on this workload.\n\n## Motivation\n\nThis is part 2 of a series of posts showing performance across various backends\nthat Ibis supports.\n\nCheck out [part 1](../pydata-performance/) if you haven't already!\n\nIn this post, I'll continue with the [Polars](../../backends/polars.qmd) and\n[DataFusion](../../backends/datafusion.qmd) backends.\n\nI show each tool using both the Ibis API and the tool's native API. We'll see\nthat the performance difference between these approaches is negligible.\n\n\n\n## Setup\n\nI ran all of the code in this blog post on a machine with these specs.\n\n| Component | Specification |\n| --------- | ------------- |\n| CPU | AMD EPYC 7B12 (64 threads) |\n| RAM | 94 GiB |\n| Disk | 1.5 TiB SSD |\n| OS | NixOS (Linux 6.1.66) |\n\n\n### Library versions\n\nHere are the versions I used to run this experiment at the time of writing.\n\n| Dependency   | Version                                                            |\n|:-------------|:-------------------------------------------------------------------|\n| Python       | 3.10.13 (main, Aug 24 2023, 12:59:26) [GCC 12.3.0]                 |\n| datafusion   | 33.0.0                                                             |\n| ibis         | [`def803155`](https://github.com/ibis-project/ibis/tree/def803155) |\n| pandas       | 2.1.4                                                              |\n| polars       | 0.19.19                                                            |\n| pyarrow      | 14.0.1                                                             |\n\n\n## Running the query across backends\n\nHere are the different Ibis expressions for each backend as well as the same\nquery with native APIs, along with timed executions of the query.\n\n### DuckDB\n\nFirst, let's run the Ibis + DuckDB version of the query from the original post:\n\n```python\nfrom __future__ import annotations\n\nimport ibis\nfrom ibis import _\n\nexpr = (\n    ibis.read_parquet(\"/data/pypi-parquet/*.parquet\")\n    .filter(\n        [\n            _.path.re_search(\n                r\"\\.(asm|c|cc|cpp|cxx|h|hpp|rs|[Ff][0-9]{0,2}(?:or)?|go)$\"\n            ),\n            ~_.path.re_search(r\"(^|/)test(|s|ing)\"),\n            ~_.path.contains(\"/site-packages/\"),\n        ]\n    )\n    .group_by(\n        month=_.uploaded_on.truncate(\"M\"),\n        ext=_.path.re_extract(r\"\\.([a-z0-9]+)$\", 1)\n        .re_replace(r\"cxx|cpp|cc|c|hpp|h\", \"C/C++\")\n        .re_replace(\"^f.*$\", \"Fortran\")\n        .replace(\"rs\", \"Rust\")\n        .replace(\"go\", \"Go\")\n        .replace(\"asm\", \"Assembly\")\n        .nullif(\"\"),\n    )\n    .aggregate(project_count=_.project_name.nunique())\n    .dropna(\"ext\")\n    .order_by([_.month.desc(), _.project_count.desc()])  # <1>\n)\ndf = expr.to_pandas()\n\n```\n\n\n::: {#5545d4a6 .cell execution_count=5}\n``` {.python .cell-code}\nduckdb_ibis_results = %timeit -n1 -r1 -o %run duckdb_ibis.py\ndf.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n29.5 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>month</th>\n      <th>ext</th>\n      <th>project_count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-11-01</td>\n      <td>C/C++</td>\n      <td>836</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023-11-01</td>\n      <td>Rust</td>\n      <td>190</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023-11-01</td>\n      <td>Fortran</td>\n      <td>48</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023-11-01</td>\n      <td>Go</td>\n      <td>33</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2023-11-01</td>\n      <td>Assembly</td>\n      <td>10</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.panel-tabset}\n\n::: {.callout-note}\n## The full dataset results are not shown here for DataFusion and Polars\nThese two engines took anywhere from 7 to 10 minutes to complete the workload,\nmaking iteration on the blog post impractical.\n:::\n\n## DataFusion\n\n::: {.panel-tabset}\n\n## Ibis\n\n```python\nfrom __future__ import annotations\n\nimport ibis\nfrom ibis import _\n\nibis.set_backend(\"datafusion\")\n\nexpr = (\n    ibis.read_parquet(\"/data/pypi-parquet/*.parquet\")\n    .filter(\n        [\n            _.path.re_search(\n                r\"\\.(asm|c|cc|cpp|cxx|h|hpp|rs|[Ff][0-9]{0,2}(?:or)?|go)$\"\n            ),\n            ~_.path.re_search(r\"(^|/)test(|s|ing)\"),\n            ~_.path.contains(\"/site-packages/\"),\n        ]\n    )\n    .group_by(\n        month=_.uploaded_on.truncate(\"M\"),\n        ext=_.path.re_extract(r\"\\.([a-z0-9]+)$\", 1)\n        .re_replace(r\"cxx|cpp|cc|c|hpp|h\", \"C/C++\")\n        .re_replace(\"^f.*$\", \"Fortran\")\n        .replace(\"rs\", \"Rust\")\n        .replace(\"go\", \"Go\")\n        .replace(\"asm\", \"Assembly\")\n        .nullif(\"\"),\n    )\n    .aggregate(project_count=_.project_name.nunique())\n    .dropna(\"ext\")\n    .order_by([_.month.desc(), _.project_count.desc()])\n)\ndf = expr.to_pandas()\n\n```\n\n\n::: {#7cbb005c .cell execution_count=7}\n``` {.python .cell-code}\ndatafusion_ibis_results = %timeit -n1 -r1 -o %run datafusion_ibis.py\ndf.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n9min 31s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>month</th>\n      <th>ext</th>\n      <th>project_count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-11-01</td>\n      <td>C/C++</td>\n      <td>836</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023-11-01</td>\n      <td>Rust</td>\n      <td>190</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023-11-01</td>\n      <td>Fortran</td>\n      <td>48</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023-11-01</td>\n      <td>Go</td>\n      <td>33</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2023-11-01</td>\n      <td>Assembly</td>\n      <td>10</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## DataFusion native\n\n<details>\n\n<summary>DataFusion SQL</summary>\n\n```sql\nSELECT\n  month,\n  ext,\n  COUNT(DISTINCT project_name) AS project_count\nFROM (\n  SELECT\n    project_name,\n    DATE_TRUNC('month', uploaded_on) AS month,\n    NULLIF(\n      REPLACE(\n        REPLACE(\n          REPLACE(\n            REGEXP_REPLACE(\n              REGEXP_REPLACE(\n                REGEXP_MATCH(path, CONCAT('(', '\\.([a-z0-9]+)$', ')'))[2],\n                'cxx|cpp|cc|c|hpp|h',\n                'C/C++',\n                'g'\n              ),\n              '^f.*$',\n              'Fortran',\n              'g'\n            ),\n            'rs',\n            'Rust'\n          ),\n          'go',\n          'Go'\n        ),\n        'asm',\n        'Assembly'\n      ),\n      ''\n    ) AS ext\n  FROM pypi\n  WHERE COALESCE(\n      ARRAY_LENGTH(\n        REGEXP_MATCH(path, '\\.(asm|c|cc|cpp|cxx|h|hpp|rs|[Ff][0-9]{0,2}(?:or)?|go)$')\n      ) > 0,\n      FALSE\n    )\n    AND NOT COALESCE(ARRAY_LENGTH(REGEXP_MATCH(path, '(^|/)test(|s|ing)')) > 0, FALSE)\n    AND NOT STRPOS(path, '/site-packages/') > 0\n)\nWHERE ext IS NOT NULL\nGROUP BY month, ext\nORDER BY month DESC, project_count DESC\n\n```\n\n\n</details>\n\n```python\nfrom __future__ import annotations\n\nimport datafusion\n\nwith open(\"./datafusion_native.sql\") as f:\n    query = f.read()\n\nctx = datafusion.SessionContext()\nctx.register_parquet(name=\"pypi\", path=\"/data/pypi-parquet/*.parquet\")\nexpr = ctx.sql(query)\n\ndf = expr.to_pandas()\n\n```\n\n\n::: {#23f7d450 .cell execution_count=10}\n``` {.python .cell-code}\ndatafusion_native_results = %timeit -n1 -r1 -o %run datafusion_native.py\ndf.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n9min 15s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>month</th>\n      <th>ext</th>\n      <th>project_count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-11-01</td>\n      <td>C/C++</td>\n      <td>836</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023-11-01</td>\n      <td>Rust</td>\n      <td>190</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023-11-01</td>\n      <td>Fortran</td>\n      <td>48</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023-11-01</td>\n      <td>Go</td>\n      <td>33</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2023-11-01</td>\n      <td>Assembly</td>\n      <td>10</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n:::\n\n## Polars\n\n::: {.panel-tabset}\n\n## Ibis\n\n```python\nfrom __future__ import annotations\n\nimport ibis\nfrom ibis import _\n\nibis.set_backend(\"polars\")\n\nexpr = (\n    ibis.read_parquet(\"/data/pypi-parquet/*.parquet\")\n    .filter(\n        [\n            _.path.re_search(\n                r\"\\.(asm|c|cc|cpp|cxx|h|hpp|rs|[Ff][0-9]{0,2}(?:or)?|go)$\"\n            ),\n            ~_.path.re_search(r\"(^|/)test(|s|ing)\"),\n            ~_.path.contains(\"/site-packages/\"),\n        ]\n    )\n    .group_by(\n        month=_.uploaded_on.truncate(\"M\"),\n        ext=_.path.re_extract(r\"\\.([a-z0-9]+)$\", 1)\n        .re_replace(r\"cxx|cpp|cc|c|hpp|h\", \"C/C++\")\n        .re_replace(\"^f.*$\", \"Fortran\")\n        .replace(\"rs\", \"Rust\")\n        .replace(\"go\", \"Go\")\n        .replace(\"asm\", \"Assembly\")\n        .nullif(\"\"),\n    )\n    .aggregate(project_count=_.project_name.nunique())\n    .dropna(\"ext\")\n    .order_by([_.month.desc(), _.project_count.desc()])\n)\ndf = expr.to_pandas(streaming=True)\n\n```\n\n\n::: {#22e41769 .cell execution_count=12}\n``` {.python .cell-code}\npolars_ibis_results = %timeit -n1 -r1 -o %run polars_ibis.py\ndf.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n7min 2s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>month</th>\n      <th>ext</th>\n      <th>project_count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-11-01</td>\n      <td>C/C++</td>\n      <td>836</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023-11-01</td>\n      <td>Rust</td>\n      <td>190</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023-11-01</td>\n      <td>Fortran</td>\n      <td>48</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023-11-01</td>\n      <td>Go</td>\n      <td>33</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2023-11-01</td>\n      <td>Assembly</td>\n      <td>10</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Polars native\n\n```python\nfrom __future__ import annotations\n\nimport polars as pl\n\nexpr = (\n    pl.scan_parquet(\"/data/pypi-parquet/*.parquet\")\n    .filter(\n        [\n            pl.col(\"path\").str.contains(\n                r\"\\.(asm|c|cc|cpp|cxx|h|hpp|rs|[Ff][0-9]{0,2}(?:or)?|go)$\"\n            ),\n            ~pl.col(\"path\").str.contains(r\"(^|/)test(|s|ing)\"),\n            ~pl.col(\"path\").str.contains(\"/site-packages/\", literal=True),\n        ]\n    )\n    .with_columns(\n        month=pl.col(\"uploaded_on\").dt.truncate(\"1mo\"),\n        ext=pl.col(\"path\")\n        .str.extract(pattern=r\"\\.([a-z0-9]+)$\", group_index=1)\n        .str.replace_all(pattern=r\"cxx|cpp|cc|c|hpp|h\", value=\"C/C++\")\n        .str.replace_all(pattern=\"^f.*$\", value=\"Fortran\")\n        .str.replace(\"rs\", \"Rust\", literal=True)\n        .str.replace(\"go\", \"Go\", literal=True)\n        .str.replace(\"asm\", \"Assembly\", literal=True)\n        .replace({\"\": None}),\n    )\n    .group_by([\"month\", \"ext\"])\n    .agg(project_count=pl.col(\"project_name\").n_unique())\n    .drop_nulls([\"ext\"])\n    .sort([\"month\", \"project_count\"], descending=True)\n)\n\ndf = expr.collect(streaming=True).to_pandas()\n\n```\n\n\n::: {#8f320240 .cell execution_count=14}\n``` {.python .cell-code}\npolars_native_results = %timeit -n1 -r1 -o %run polars_native.py\ndf.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n7min 45s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>month</th>\n      <th>ext</th>\n      <th>project_count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2023-11-01</td>\n      <td>C/C++</td>\n      <td>836</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2023-11-01</td>\n      <td>Rust</td>\n      <td>190</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2023-11-01</td>\n      <td>Fortran</td>\n      <td>48</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2023-11-01</td>\n      <td>Go</td>\n      <td>33</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2023-11-01</td>\n      <td>Assembly</td>\n      <td>10</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n:::\n\n:::\n\n## Takeaways\n\n**Ibis + DuckDB is the only system tested that handles this workload well out of the box**\n\n* Both Polars and DataFusion are much slower than DuckDB and Dask on this\n  workload.\n* Polars memory use fluctuated quite bit, while DataFusion's memory profile was\n  similar to DuckDB.\n\nLet's recap the results with some numbers:\n\n### Numbers\n\n| Toolset | Data size | Duration | Throughput |\n| ------------------ | --------: | -----------: | ---------: |\n| Ibis + DuckDB | 25,825 MiB | 30 seconds | 874 MiB/s |\n| Ibis + Polars | 25,825 MiB | 422 seconds | 61 MiB/s |\n| Polars native API | 25,825 MiB | 465 seconds | 56 MiB/s |\n| DataFusion native API | 25,825 MiB | 556 seconds | 46 MiB/s |\n| Ibis + DataFusion | 25,825 MiB | 572 seconds | 45 MiB/s |\n\n\n## Conclusion\n\nIf you're considering Polars for new code, give Ibis a try with the [DuckDB\nbackend](../../backends/duckdb.qmd).\n\nYou'll get better performance than Polars on some workloads, and with a broader\ncross-backend API that helps you scale from development to production.\n\nIf you find that Polars has better performance than DuckDB on a particular\nworkload you can always switch to the Polars backend for that workload.\n\nEveryone wins!\n\nIn the next post in this series we'll cover the cloud backends: Snowflake,\nBigQuery, Trino and ClickHouse.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}