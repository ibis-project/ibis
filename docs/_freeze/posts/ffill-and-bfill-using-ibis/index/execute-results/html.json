{
  "hash": "3f1e224f86b8b1f15c31f1c1ad1c99aa",
  "result": {
    "markdown": "---\ntitle: \"`ffill` and `bfill` using Ibis\"\nauthor: Patrick Clarke\ndate: 2022-09-09\ncategories:\n    - blog\n    - window functions\n    - time series\n---\n\nSuppose you have a table of data mapping events and dates to values, and that this data contains gaps in values.\n\nSuppose you want to forward fill these gaps such that, one-by-one,\nif a value is null, it is replaced by the non-null value preceding.\n\nFor example, you might be measuring the total value of an account over time.\nSaving the same value until that value changes is an inefficient use of space,\nso you might only measure the value during certain events,\nlike a change in ownership or value.\n\nIn that case, to view the value of the account by day, you might want to interpolate dates\nand then ffill or bfill value to show the account value over time by date.\n\nDate interpolation will be covered in a different guide,\nbut if you already have the dates then you can fill in some values.\n\nThis was heavily inspired by Gil Forsyth's writeup on ffill and bfill on the\n[Ibis GitHub Wiki](https://github.com/ibis-project/ibis/wiki/ffill-and-bfill-using-window-functions).\n\n### Setup\n\nFirst, we want to make some mock data.\nTo demonstrate this technique in a non-pandas backend, we will use the DuckDB backend.\n\nOur data will have measurements by date, and these measurements will be grouped by an event id.\nWe will then save this data to `data.parquet` so we can register that parquet file as a table in our DuckDB connector.\n\n::: {#5331b1af .cell execution_count=1}\n``` {.python .cell-code}\nfrom datetime import date\n\nimport numpy as np\nimport pandas as pd\n\nimport ibis\n\n\ndf = pd.DataFrame(\n    {\n        \"event_id\": [0] * 2 + [1] * 3 + [2] * 5 + [3] * 2,\n        \"measured_on\": map(\n            date,\n            [2021] * 12, [6] * 4 + [5] * 6 + [7] * 2,\n            range(1, 13),\n        ),\n        \"measurement\": np.nan,\n    }\n)\n\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>event_id</th>\n      <th>measured_on</th>\n      <th>measurement</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>2021-06-01</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0</td>\n      <td>2021-06-02</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>2021-06-03</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>2021-06-04</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1</td>\n      <td>2021-05-05</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#7640d42d .cell execution_count=2}\n``` {.python .cell-code}\ndf.loc[[1, 4, 5, 7], \"measurement\"] = [5.0, 42.0, 42.0, 11.0]\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>event_id</th>\n      <th>measured_on</th>\n      <th>measurement</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>2021-06-01</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0</td>\n      <td>2021-06-02</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>2021-06-03</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>2021-06-04</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1</td>\n      <td>2021-05-05</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2</td>\n      <td>2021-05-06</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>2</td>\n      <td>2021-05-07</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>2</td>\n      <td>2021-05-08</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>2</td>\n      <td>2021-05-09</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>2</td>\n      <td>2021-05-10</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>3</td>\n      <td>2021-07-11</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>3</td>\n      <td>2021-07-12</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nLet's write that to a parquet file:\n\n::: {#d880ddca .cell execution_count=3}\n``` {.python .cell-code}\ndf.to_parquet(\"data.parquet\")\n```\n:::\n\n\nTo use the DuckDB backend with our data, we will spin up a DuckDB connection and then register `data.parquet` as `data`:\n\n::: {#99364917 .cell execution_count=4}\n``` {.python .cell-code}\nconn = ibis.connect('duckdb://')\n\nconn.register('data.parquet', table_name='data')\n\ndata = conn.table(\"data\")\n\ndata\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\">DatabaseTable: data\n  event_id    int64\n  measured_on date\n  measurement float64\n</pre>\n```\n:::\n:::\n\n\n### `ffill` Strategy\n\nTo better understand how we can forward-fill our gaps, let's take a minute to explain the strategy and then look at\nthe manual result.\n\nWe will partition our data by event groups and then sort those groups by date.\n\nOur logic for forward fill is then: let `j` be an event group sorted by date and let `i` be a date within `j`.\nIf `i` is the first date in `j`, then continue.\nIf `i` is not the first date in `j`, then if `measurement` in `i` is null then replace it with `measurement` for `i-1`.\nOtherwise, do nothing.\n\nLet's take a look at what this means for the first few rows of our data:\n\n```\n    event_id measured_on  measurement\n0          0  2021-06-01          NaN # Since this is the first row of the event group (group 0), do nothing\n1          0  2021-06-02          5.0 # Since this is not the first row of the group and is not null: do nothing\n4          1  2021-05-05         42.0 # This is the first row of the event group (group 1): do nothing\n2          1  2021-06-03          NaN # This is not the first row and is null: replace it (NaN → 42.0)\n3          1  2021-06-04          NaN # This is not the first row and is null: replace it (NaN → 42.0)\n5          2  2021-05-06         42.0 # This is the first row of the event group (group 2): do nothing\n6          2  2021-05-07          NaN # This is not the first row and is null: replace it (NaN → 42.0)\n7          2  2021-05-08         11.0 # This is not the first row and is not null: do nothing\n8          2  2021-05-09          NaN # This is not the first row and is null: replace it (NaN → 11.0)\n9          2  2021-05-10          NaN # This is not the first row and is null: replace it (NaN → 11.0)\n10         3  2021-07-11          NaN # This is the first row of the event group (group 3): do nothing\n11         3  2021-07-12          NaN # This is not the first row and is null: replace it (NaN → NaN)\n```\n\nOur result should for forward fill should look like this:\n\n::: {#d25676e9 .cell execution_count=5}\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>event_id</th>\n      <th>measured_on</th>\n      <th>measurement</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>2021-06-01</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0</td>\n      <td>2021-06-02</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>2021-06-03</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>2021-06-04</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1</td>\n      <td>2021-05-05</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2</td>\n      <td>2021-05-06</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>2</td>\n      <td>2021-05-07</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>2</td>\n      <td>2021-05-08</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>2</td>\n      <td>2021-05-09</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>2</td>\n      <td>2021-05-10</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>3</td>\n      <td>2021-07-11</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>3</td>\n      <td>2021-07-12</td>\n      <td>11.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTo accomplish this, we will create a window over our `event_id` to partition our data into groups.\nWe will take these groups and order them by `measured_on`:\n\n::: {#7d4448df .cell execution_count=6}\n``` {.python .cell-code}\nwin = ibis.window(group_by=data.event_id, order_by=data.measured_on, following=0)\n```\n:::\n\n\nOnce we have our window defined, we can flag the first non-null value in an event group using `count`,\nas it will count non-null values row-by-row within our group:\n\n::: {#f8567f1c .cell execution_count=7}\n``` {.python .cell-code}\ngrouped = data.mutate(grouper=data.measurement.count().over(win))\n\ngrouped.execute().sort_values(by=['event_id', 'measured_on'])\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>event_id</th>\n      <th>measured_on</th>\n      <th>measurement</th>\n      <th>grouper</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>2021-06-01</td>\n      <td>NaN</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0</td>\n      <td>2021-06-02</td>\n      <td>5.0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>1</td>\n      <td>2021-05-05</td>\n      <td>42.0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>1</td>\n      <td>2021-06-03</td>\n      <td>NaN</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>1</td>\n      <td>2021-06-04</td>\n      <td>NaN</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2</td>\n      <td>2021-05-06</td>\n      <td>42.0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>2</td>\n      <td>2021-05-07</td>\n      <td>NaN</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2</td>\n      <td>2021-05-08</td>\n      <td>11.0</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2</td>\n      <td>2021-05-09</td>\n      <td>NaN</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>2</td>\n      <td>2021-05-10</td>\n      <td>NaN</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>3</td>\n      <td>2021-07-11</td>\n      <td>NaN</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>3</td>\n      <td>2021-07-12</td>\n      <td>NaN</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTo see this a bit clearer: look at rows 0, 1, and 2.\nRow 0 is NaN and is the first row of the group (event_id = 0), so at row 0 we have 0 non-null values (grouper = 0).\nRow 1 is not null (5.0) and is the second row the group, so our count has increased by 1 (grouper = 1).\nRow 2 is the first row of its group (event_id = 1) and is not null, so our count is 1 (grouper = 1).\n\nSkip down to rows 9, 10, and 11.\nRow 9 is the sixth row of group 2 and there are three non-null values in group 2 before row 9.\nTherefore the count at row 9 is 3.\n\nRow 10 is the first row of group 3 and is null, therefore its count is 0.\nFinally: row 11 is the second row of group 3 and is null as well, therefore the count remains 0.\n\nUnder this design, we now have another partition.\n\nOur first partition is by `event_id`.\nWithin each set in that partition, we have a partition by `grouper`, where each set has up to one non-null value.\n\nSince there less than or equal to one non-null value in each group of\n`['event_id', 'grouper']`, we can fill values by overwriting _all_ values within\nthe group by the max value in the group.\n\nSo:\n\n1. Group by `event_id` and `grouper`\n2. Mutate the data along that grouping by populating a new column `ffill` with the `max` value of `measurement`.\n\n::: {#a5c2237e .cell execution_count=8}\n``` {.python .cell-code}\nresult = (\n    grouped\n    .group_by([grouped.event_id, grouped.grouper])\n    .mutate(ffill=grouped.measurement.max())\n    .execute()\n).sort_values(by=['event_id', 'measured_on']).reset_index(drop=True)\n\nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>event_id</th>\n      <th>measured_on</th>\n      <th>measurement</th>\n      <th>grouper</th>\n      <th>ffill</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>2021-06-01</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0</td>\n      <td>2021-06-02</td>\n      <td>5.0</td>\n      <td>1</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>2021-05-05</td>\n      <td>42.0</td>\n      <td>1</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>2021-06-03</td>\n      <td>NaN</td>\n      <td>1</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1</td>\n      <td>2021-06-04</td>\n      <td>NaN</td>\n      <td>1</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2</td>\n      <td>2021-05-06</td>\n      <td>42.0</td>\n      <td>1</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>2</td>\n      <td>2021-05-07</td>\n      <td>NaN</td>\n      <td>1</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>2</td>\n      <td>2021-05-08</td>\n      <td>11.0</td>\n      <td>2</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>2</td>\n      <td>2021-05-09</td>\n      <td>NaN</td>\n      <td>2</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>2</td>\n      <td>2021-05-10</td>\n      <td>NaN</td>\n      <td>2</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>3</td>\n      <td>2021-07-11</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>3</td>\n      <td>2021-07-12</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### `bfill` Strategy\n\nInstead of sorting the dates ascending, we will sort them descending.\nThis is akin to starting at the last row in an event group and going backwards using the same logic outlined above.\n\nLet's take a look:\n\n```\n    event_id measured_on  measurement  grouper\n0          0  2021-06-01          NaN        1 # null, take the previous row value (NaN → 5.0)\n1          0  2021-06-02          5.0        1 # last row, do nothing\n2          1  2021-05-05         42.0        1 # not null, do nothing\n3          1  2021-06-03          NaN        0 # null, take previous row value (NaN → NaN)\n4          1  2021-06-04          NaN        0 # last row, do nothing\n5          2  2021-05-06         42.0        2 # not null, do nothing\n6          2  2021-05-07          NaN        1 # null, take previous row value (NaN → 11.0)\n7          2  2021-05-08         11.0        1 # not null, do nothing\n8          2  2021-05-09          NaN        0 # null, take previous row value (NaN → NaN)\n9          2  2021-05-10          NaN        0 # not null, do nothing\n10         3  2021-07-11          NaN        0 # null, take previous row value (NaN → NaN)\n11         3  2021-07-12          NaN        0 # last row, do nothing\n```\n\nCodewise, `bfill` follows the same strategy as `ffill`, we need to specify `order_by` to use `ibis.desc`.\nThis will flip our dates and our counts (therefore our `grouper`s) will start backwards.\n\n::: {#d630f1e3 .cell execution_count=9}\n``` {.python .cell-code}\nwin = ibis.window(group_by=data.event_id, order_by=ibis.desc(data.measured_on), following=0)\n\ngrouped = data.mutate(grouper=data.measurement.count().over(win))\n\ngrouped.execute().sort_values(by=['event_id', 'measured_on']).reset_index(drop=True)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>event_id</th>\n      <th>measured_on</th>\n      <th>measurement</th>\n      <th>grouper</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>2021-06-01</td>\n      <td>NaN</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0</td>\n      <td>2021-06-02</td>\n      <td>5.0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>2021-05-05</td>\n      <td>42.0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>2021-06-03</td>\n      <td>NaN</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1</td>\n      <td>2021-06-04</td>\n      <td>NaN</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2</td>\n      <td>2021-05-06</td>\n      <td>42.0</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>2</td>\n      <td>2021-05-07</td>\n      <td>NaN</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>2</td>\n      <td>2021-05-08</td>\n      <td>11.0</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>2</td>\n      <td>2021-05-09</td>\n      <td>NaN</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>2</td>\n      <td>2021-05-10</td>\n      <td>NaN</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>3</td>\n      <td>2021-07-11</td>\n      <td>NaN</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>3</td>\n      <td>2021-07-12</td>\n      <td>NaN</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAnd, again, if we take max of our `grouper` value, we will get the only non-null value if it exists:\n\n::: {#c94230f2 .cell execution_count=10}\n``` {.python .cell-code}\nresult = (\n    grouped\n    .group_by([grouped.event_id, grouped.grouper])\n    .mutate(bfill=grouped.measurement.max())\n    .execute()\n).sort_values(by=['event_id', 'measured_on']).reset_index(drop=True)\n\nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>event_id</th>\n      <th>measured_on</th>\n      <th>measurement</th>\n      <th>grouper</th>\n      <th>bfill</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>2021-06-01</td>\n      <td>NaN</td>\n      <td>1</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0</td>\n      <td>2021-06-02</td>\n      <td>5.0</td>\n      <td>1</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>2021-05-05</td>\n      <td>42.0</td>\n      <td>1</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>2021-06-03</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1</td>\n      <td>2021-06-04</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2</td>\n      <td>2021-05-06</td>\n      <td>42.0</td>\n      <td>2</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>2</td>\n      <td>2021-05-07</td>\n      <td>NaN</td>\n      <td>1</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>2</td>\n      <td>2021-05-08</td>\n      <td>11.0</td>\n      <td>1</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>2</td>\n      <td>2021-05-09</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>2</td>\n      <td>2021-05-10</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>3</td>\n      <td>2021-07-11</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>3</td>\n      <td>2021-07-12</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### `bfill` and `ffill` without Event Groups\n\nYou can `bfill` and `ffill` without event groups by ignoring that grouping.\nRemove all references of `event_id` and you can treat the entire dataset as one event.\n\nYour window function will increment whenever a new non-null value is observed, creating that partition where each\nset has up to one non-null value.\n\nFor example, reasoning through `bfill`:\n\n::: {#401e3b62 .cell execution_count=11}\n``` {.python .cell-code}\ndata.execute().sort_values(by=['measured_on'])\n\nwin = ibis.window(order_by=ibis.desc(data.measured_on), following=0)\n\ngrouped = data.mutate(grouper=data.measurement.count().over(win))\n\nresult = (\n    grouped\n    .group_by([grouped.grouper])\n    .mutate(bfill=grouped.measurement.max())\n)\n\nresult.execute().sort_values(by=['measured_on'])\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>event_id</th>\n      <th>measured_on</th>\n      <th>measurement</th>\n      <th>grouper</th>\n      <th>bfill</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>10</th>\n      <td>1</td>\n      <td>2021-05-05</td>\n      <td>42.0</td>\n      <td>4</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>11</th>\n      <td>2</td>\n      <td>2021-05-06</td>\n      <td>42.0</td>\n      <td>3</td>\n      <td>42.0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>2</td>\n      <td>2021-05-07</td>\n      <td>NaN</td>\n      <td>2</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2</td>\n      <td>2021-05-08</td>\n      <td>11.0</td>\n      <td>2</td>\n      <td>11.0</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>2</td>\n      <td>2021-05-09</td>\n      <td>NaN</td>\n      <td>1</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>2</td>\n      <td>2021-05-10</td>\n      <td>NaN</td>\n      <td>1</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>0</td>\n      <td>2021-06-01</td>\n      <td>NaN</td>\n      <td>1</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>0</td>\n      <td>2021-06-02</td>\n      <td>5.0</td>\n      <td>1</td>\n      <td>5.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1</td>\n      <td>2021-06-03</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1</td>\n      <td>2021-06-04</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>3</td>\n      <td>2021-07-11</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>3</td>\n      <td>2021-07-12</td>\n      <td>NaN</td>\n      <td>0</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAs an exercise, try to take your time and reason your way through `ffill`.\n\nHappy coding!\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}