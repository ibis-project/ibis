---
title: "Test 20 databases on every commit"
subtitle: "You can, it's not hyperbole"
author:
  - Phillip Cloud
execute:
  echo: true
format:
  revealjs:
    footer: <https://ibis-project.org>
    chalkboard: true
    # https://quarto.org/docs/presentations/revealjs/themes.html#using-themes
    theme: dark
---

# what

## maybe this is you

![](./docker-eye-roll.gif){fig-align="center"}

## or this

![](./wonka.png){fig-align="center"}

## or maybe even this

![](./basement-ci.jpeg){fig-align="center"}

## this talk isn't earth shattering

opinions informed by experience

:::: {.columns}

::: {.column width="50%"}
### overview

- what we learned about maintenance building Ibis
- day to day of supporting 20+ databases
- unique challenges
:::

::: {.column width="50%"}
### topics

- some docker stuff
- some packaging stuff
- pytest plugins you should be using
:::
::::

# quick overview of Ibis

## Ibis is a Python library for:

- exploratory data analysis (EDA)
- analytics
- data engineering
- ML preprocessing
- building your own dataframe library

::: {.r-fit-text}
dev to prod with the same API
:::

## Getting started...

```{python}
#| code-fold: true
#| echo: false

import ibis

t = ibis.examples.penguins.fetch()
t.to_parquet("penguins.parquet")
```

```{python}
import ibis

ibis.options.interactive = True
```

```{python}
t = ibis.read_parquet("penguins.parquet")
t.head(3)
```

## One API, 20+ backends {.smaller .scrollable}

::: {.panel-tabset}

## DuckDB

```{python}
con = ibis.connect("duckdb://")
```

```{python}
t = con.read_parquet("penguins.parquet")
t.head(3)
```

```{python}
t.group_by("species", "island").agg(count=t.count()).order_by("count")
```

## Polars

```{python}
con = ibis.connect("polars://")
```

```{python}
t = con.read_parquet("penguins.parquet")
t.head(3)
```

```{python}
t.group_by("species", "island").agg(count=t.count()).order_by("count")
```

## DataFusion

```{python}
con = ibis.connect("datafusion://")
```

```{python}
t = con.read_parquet("penguins.parquet")
t.head(3)
```

```{python}
t.group_by("species", "island").agg(count=t.count()).order_by("count")
```

## PySpark

```{python}
con = ibis.connect("pyspark://")
```

```{python}
t = con.read_parquet("penguins.parquet")
t.head(3)
```

```{python}
t.group_by("species", "island").agg(count=t.count()).order_by("count")
```

## 16+ other things

![](./machine.gif){fig-align="center" width="100%" height="100%"}

:::

## how it works

Ibis compiles down to SQL or dataframe code:

```{python}
#| echo: false

import os
import sys
sys.path.append(os.path.abspath(".."))

from backends_sankey import fig
fig.show()
```

# what's in Ibis?

## by the numbers {.smaller}

:::: {.columns}
::: {.column width="50%"}
### backends
- **17** SQL
- **3** non-SQL
- **2** cloud
:::

::: {.column width="50%"}
### engines + APIs
- **9** distributed SQL
- **3** dataframe
- oldest: **~45** years üëÄ
- newest: **~2** years
:::
::::

### other facts

- latency is wild
- deployment models vary

::: {.fragment}
::: {.r-fit-text}
_‚Ä¶ **feature development**_‚ùì
:::
:::

## bit of a pickle

![](./picklerick.png)

# how

## high level

### goal: fast iteration

- fast env setup (dep mgmt)
- (less) fast tests (testing)
- high **job** concurrency (ci/provider)
- **easy to run**: dev speed ([`just`](https://github.com/casey/just))

::: {.fragment}
::: {.r-fit-text}
_CI must complete "quickly"_
:::
:::

## tools: overview

- **deps**: poetry
- **ci**: GitHub Actions
- **beasts**: docker
- **house pets**: docker
- cool kids don't get special tx (duckdb, polars)
- task runner (e.g.: `just up postgres`)

## tools: poetry

::: {.callout-warning}
## Opinions follow
:::

- **env setup needs to be _fast_**: avoid SAT
- poetry is one way; there are others
- get yourself a lockfile

::: {.fragment}
::: {.r-fit-text}
‚Ä¶ _are you doing that **now**_‚ùî‚ùì
:::
:::

## tools: docker

- Sure, docker
- But, do you to use it locally?
- Use health checks; "dumb" ones are fine
- Focus: make it easy for devs to use

## tools: GitHub actions

- Pay for the Teams plan ([more concurrency](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#usage-limits))
- Automate dep updates via Renovate/Dependabot

::: {.columns}
::: {.column width="50%"}
### GHA concurrency limits

![](./gha.png)
:::

::: {.column width="50%"}
### ibis CI cost

![](./bill.png)
:::
:::

## pytest {.smaller}

### Ibis problems

- Backends don't implement the same stuff
- Need to know when backend passes
- Need to specify exception type it raises
- Answer questions like: "will it _ever_ blend?"

::: {.fragment}
### markers + hooks

```python
@pytest.mark.never("duckdb")  # never gonna happen
@pytest.mark.notyet("impala")  # might happen
@pytest.mark.notimpl("snowflake")  # ibis devs: do some work
def test_soundex():
    ...

def pytest_ignore_collect(...):
    # pytest -m duckdb: don't collect things that aren't marked duckdb
    ...
```
:::

## pytest: plugins

**`pytest-`**

- `xdist`: try to make this work if you can
- `randomly`: exposes your bogus and stateful assumptions
- `repeat`: great when randomly has exposed your shenanigans
- `clarity`: failing test diffs are **much** more readable
- `snapshot`: better than that giant `f`-string you just wrote

# summary

- use docker for dev **and** "prod"
- lock your dependencies*
- auto update stuff where it makes sense
- pytest probably has a thing for that
- track ci run durations, somehow

# questions?
